[{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://emilmip.github.io/LTFGRS/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://emilmip.github.io/LTFGRS/articles/LTFGRS_workflow_prediction.html","id":"simulate-mock-trio-phenotype-and-cip-data","dir":"Articles","previous_headings":"","what":"Simulate mock trio, phenotype, and CIP data","title":"LTFGRS Workflow: Prepare Genetic Liability for Prediction","text":"set population parameters simulation. parameters follows:","code":"# population parameters and seed set.seed(555) h2 = .5 # heritability K = .3 # population prevalence"},{"path":"https://emilmip.github.io/LTFGRS/articles/LTFGRS_workflow_prediction.html","id":"cumulative-incidence-proportions-cip","dir":"Articles","previous_headings":"Simulate mock trio, phenotype, and CIP data","what":"Cumulative incidence proportions (CIP)","title":"LTFGRS Workflow: Prepare Genetic Liability for Prediction","text":"One key required input variables LTFGRS population representative stratified cumulative incidence proportions (CIP) data. LTFGRS able utilise population representative stratified CIPs personalise thresholds liability-based predictors. CIPs typically obtained large population registers sources allow population representative estimates. , simulate format similar stratified CIPs may stored. assume CIPs stratified sex birth year. population representative stratified CIPs interpretation proportion individuals born given year sex diagnosed outcome interest age xx.","code":"# assuming we have been provided a CIP object of the following style: CIP = expand.grid(list(age = 1:100,                        birth_year = 1900:2024,                        sex = 0:1)) %>%   group_by(sex, birth_year) %>%   mutate(cip = (1:n() - 1)/n() * K) %>%   ungroup() %>%    print(n = 10) #> # A tibble: 25,000 × 4 #>      age birth_year   sex   cip #>    <int>      <int> <int> <dbl> #>  1     1       1900     0 0     #>  2     2       1900     0 0.003 #>  3     3       1900     0 0.006 #>  4     4       1900     0 0.009 #>  5     5       1900     0 0.012 #>  6     6       1900     0 0.015 #>  7     7       1900     0 0.018 #>  8     8       1900     0 0.021 #>  9     9       1900     0 0.024 #> 10    10       1900     0 0.027 #> # ℹ 24,990 more rows"},{"path":"https://emilmip.github.io/LTFGRS/articles/LTFGRS_workflow_prediction.html","id":"trio-information","dir":"Articles","previous_headings":"Simulate mock trio, phenotype, and CIP data","what":"Trio information","title":"LTFGRS Workflow: Prepare Genetic Liability for Prediction","text":"trio information presented manually constructed resemble typical way trio data may stored. names chosen resemble relationship proband. means simple names “dad”, “mom”, “sib”. also complex names “pgf” maternal grand father, “muncle” maternal uncle”, “hsmcousin” half-sibiling maternal cousin, etc. suffixes “H” “W” mean husband wife, respectively.","code":"# hand curated trio information, taken from LTFHPlus vignette: # https://emilmip.github.io/LTFHPlus/articles/FromTrioToFamilies.html family = tribble(   ~id, ~momcol, ~dadcol,   \"pid\", \"mom\", \"dad\",   \"sib\", \"mom\", \"dad\",   \"mhs\", \"mom\", \"dad2\",   \"phs\", \"mom2\", \"dad\",   \"mom\", \"mgm\", \"mgf\",   \"dad\", \"pgm\", \"pgf\",   \"dad2\", \"pgm2\", \"pgf2\",   \"paunt\", \"pgm\", \"pgf\",   \"pacousin\", \"paunt\", \"pauntH\",   \"hspaunt\", \"pgm\", \"newpgf\",   \"hspacousin\", \"hspaunt\", \"hspauntH\",   \"puncle\", \"pgm\", \"pgf\",   \"pucousin\", \"puncleW\", \"puncle\",   \"maunt\", \"mgm\", \"mgf\",   \"macousin\", \"maunt\", \"mauntH\",   \"hsmuncle\", \"newmgm\", \"mgf\",   \"hsmucousin\", \"hsmuncleW\", \"hsmuncle\" )"},{"path":"https://emilmip.github.io/LTFGRS/articles/LTFGRS_workflow_prediction.html","id":"phenotype-data","dir":"Articles","previous_headings":"Simulate mock trio, phenotype, and CIP data","what":"Phenotype data","title":"LTFGRS Workflow: Prepare Genetic Liability for Prediction","text":"simulate liability based family structure defined assign case-control outcome individual. covariates sex age randomly assigned. get case-control status, first generate (population) graph, calculate kinship matrix based heritability kinship coefficient, finally, draw liabilities multivariate normal calculated kinship matrix covariance matrix. Next, create mock phenotype data: mock phenotype data intended resemble format can typically derived register bio bank phenotypes age diagnosis available. Columns interest : fdato: birth date individual birth_year: birth year individual adhd: outcome interest, indiv_eof: personalised end follow given individual. may different individual due number censoring competing events.","code":"# creating a graph for the family graph = prepare_graph(.tbl = family, icol = \"id\", mcol = \"momcol\", fcol = \"dadcol\") # calculating the kinship matrix based on the graph cov_mat = get_covmat(fam_graph = graph, h2 = h2, index_id = \"pid\") # creating a phenotype for the family liabs = MASS::mvrnorm(n = 1, mu = rep(0, nrow(cov_mat)), Sigma = cov_mat) # these values are simulated only for illustrative purposes and not to make sense(!) pheno = tibble(   id = names(liabs),   status = liabs > qnorm(K, lower.tail = F),   # no consideration for generation etc in sex, fdato or birth_year:   sex = sample(0:1, size = length(liabs), replace = TRUE),   fdato = dmy(paste0(sample(1:28, length(liabs), replace = T), \"/\", sample(1:12, length(liabs), replace = T), \"/\", sample(1940:2000, length(liabs), replace = T))),   birth_year = year(fdato),   # age of onset only after fdato   adhd = purrr::map2_chr(.x = status, .y = birth_year,       ~ if(.x) paste0(sample(1:28, 1), \"/\", sample(1:12, 1), \"/\", sample((.y + 1):2023, 1)) else NA),   # end of follow up assigned here   indiv_eof = dmy(\"31/12/2010\")) %>%   mutate(     # converting to date format     adhd = dmy(adhd)) %>%   filter(id != \"pid_g\") %>% # remove the genetic liability of the proband   # status is not required here. Only used it to generate the age of diagnosis.   select(-status)  paged_table(pheno)"},{"path":"https://emilmip.github.io/LTFGRS/articles/LTFGRS_workflow_prediction.html","id":"preparing-for-estimate_liability","dir":"Articles","previous_headings":"","what":"Preparing for estimate_liability()","title":"LTFGRS Workflow: Prepare Genetic Liability for Prediction","text":"real world scenario, access information used . assume objects CIP, family, pheno information available user. objects hold information can often extracted population registers bio banks. CIP: CIP object carry information prevalence outcome interest population therefore also participant fits population distribution. family: family object holds trio information, .e. information family structure individual related . real world scenario object may contains millions unique individuals. pheno: pheno object holds phenotypic information individual present trio information.","code":""},{"path":"https://emilmip.github.io/LTFGRS/articles/LTFGRS_workflow_prediction.html","id":"automatic-identification-of-n-degree-relatives","dir":"Articles","previous_headings":"Preparing for estimate_liability()","what":"Automatic identification of n-degree relatives","title":"LTFGRS Workflow: Prepare Genetic Liability for Prediction","text":"want calculate family genetic risk score, need create pedigree based proband relations relative proband. interested identifying family members degree relatedness, nn, without manually find family members. Manually identifying family members degree 44 time consuming error prone. implemented automatic detection family members utilise graph based individuals trio information (ideally population registers) neighbourhood graphs. short, create pedigree (directed graph) every individual trio data copy sections around proband individuals nn steps away proband graph (neighbourhood graphs degree n, called family graph). function get_family_graphs() return formatted tibble. output two columns specified arguments, fid fam_graph_col. fid ids provided probands, also individuals neighbourhood (family) graphs centred . Note: example , one family graph given proband, however, individual may still appear several family graphs relative. E.g., parent two children may appearing family graph children. fam_graph_col holds family graphs format igraph. Operations level required average user. igraph object shown context: TODO: add graph_to_trio LTFGRS plot family graph illustrate new pedigree.","code":"# Identify family members of degree n family_graphs = get_family_graphs(pop_graph = graph,                                   ndegree = 1,                                   proband_vec = pheno$id,                                   fid = \"fid\",                                   fam_graph_col = \"fam_graph\") family_graphs %>% print(n = 4) #> # A tibble: 31 × 2 #>   fid   fam_graph #>   <chr> <list>    #> 1 dad   <igraph>  #> 2 mom   <igraph>  #> 3 dad2  <igraph>  #> 4 mom2  <igraph>  #> # ℹ 27 more rows family_graphs$fam_graph[[1]] #> IGRAPH db340a9 DN-- 8 17 --  #> + attr: name (v/c) #> + edges from db340a9 (vertex names): #>  [1] dad   ->paunt  dad   ->puncle dad   ->sib    dad   ->pid    dad   ->phs    #>  [6] pgf   ->dad    pgf   ->paunt  pgf   ->puncle pgm   ->dad    pgm   ->paunt  #> [11] pgm   ->puncle paunt ->dad    paunt ->puncle puncle->dad    puncle->paunt  #> [16] sib   ->pid    pid   ->sib"},{"path":"https://emilmip.github.io/LTFGRS/articles/LTFGRS_workflow_prediction.html","id":"censoring-of-future-events-on-a-family-basis","dir":"Articles","previous_headings":"Preparing for estimate_liability()","what":"Censoring of future events on a family basis","title":"LTFGRS Workflow: Prepare Genetic Liability for Prediction","text":"purpose genetic liability estimated prediction. epidemiology (many fields) emphasis ensuring future events used base predictions . Hence, need ensure , within family, events happen end follow proband used estimate genetic liability proband. real world analysis, end follow can due proband diagnosed censoring event, end register follow , emigration, death. function familywise_censoring() offers way censor future events family basis, censoring events happen end follow proband (indiv_eof). function familywise_censoring() return tibble following additional columns: status: Assigned case-control status based family-wise censoring time, .e. event happened end follow family, status set FALSE (0). aod: age diagnosis, NA controls. age: age end family-wise follow . information used calculate personalised thresholds individual also accounting fact family may differing levels information available .","code":"# calculate family specific thresholds info = familywise_censoring(   family_graphs = family_graphs,   tbl = pheno,   start = \"fdato\",   end = \"indiv_eof\",   event = \"adhd\",   merge_by = setNames(c(\"id\"), c(\"pid\")))  paged_table(info)"},{"path":"https://emilmip.github.io/LTFGRS/articles/LTFGRS_workflow_prediction.html","id":"assign-thresholds-to-censored-families","dir":"Articles","previous_headings":"Preparing for estimate_liability()","what":"Assign thresholds to censored families","title":"LTFGRS Workflow: Prepare Genetic Liability for Prediction","text":"status, aod, age known, can assign thresholds family family members. Notably, means individual appears multiple families, e.g. proband relative different proband, individual may multiple (potentially different) thresholds assigned . use fid pid helps ensure individual can still uniquely identified. Due data privacy, possible encounter CIPs values provided set values, e.g. CIP value whole year birth year sex, shown CIP object. However, observed ages (age diagnosis) typically integer values. means may need approximate CIP values provided values. offer XGboost based approach interpolate CIPs provided values. Note: Currently, possible experience negative ages end follow . due family-wise end follow ending individual born, e.g. proband diagnosed youth, child later life. individuals get non-informative threshold (−∞-\\infty max min_CIP_value predicted CIP [K_i]). words, individuals impact estimate. function prepare_thresholds() several options worth pointing . first lower_equal_upper, used determine upper lower thresholds cases . may useful CIP values considered accurate, may lead accurate genetic liability estimates. second personal_thr, specifies thresholds based K_i K_pop. Basing thresholds K_i yields personalised thresholds based stratification CIPs. function prepare_thresholds() return tibble following additional columns: K_i: CIP value individual. K_i predicted interpolation used. K_pop: population prevalence. Currently calculated maximum CIP value within CIP stratum individual belongs , e.g. male born 20002000, K_pop maximum CIP value observed among males born year 20002000. thr: liability threshold used determine case-control status. thr used determine upper lower thresholds individual. lower: lower threshold individual. upper: upper threshold individual. mixture model used calculate genetic liability, lower upper needed.","code":"fam_thrs = prepare_thresholds(   .tbl = info,   CIP = CIP,   age_col = \"age\" ,   lower_equal_upper = FALSE,   personal_thr = TRUE,    fid_col = \"fid\",   personal_id_col = \"pid\",   interpolation = \"xgboost\" ) paged_table(fam_thrs)"},{"path":"https://emilmip.github.io/LTFGRS/articles/LTFGRS_workflow_prediction.html","id":"assign-thresholds-to-family-graphs","dir":"Articles","previous_headings":"Preparing for estimate_liability()","what":"Assign thresholds to family graphs","title":"LTFGRS Workflow: Prepare Genetic Liability for Prediction","text":"function estimate_liability() can use family graphs calculate necessary values genetic liability, thresholds stored attributes family graphs. can attach thresholds fam_thrs family_graphs function familywise_attach_attributes(). function merges fid column attaches columns fam_attr specified cols_to_attach. Since purpose genetic liability estimating prediction, wish use information proband. mask proband’s information setting upper lower values ∞\\infty −∞-\\infty (non-informative values) argument censor_proband_thrs = TRUE. format similar one used get_family_graphs(). worth noting arguement censor_proband_thrs required purpose resulting genetic liability prediction. second row igraph (starting “+attr:”) shows attributes available node graph.","code":"# attach family specific thresholds ltfgrs_input = familywise_attach_attributes(family_graphs = family_graphs,                                             fam_attr = fam_thrs,                                             fam_graph_col = \"fam_graph\",                                             attached_fam_graph_col = \"masked_fam_graph\",                                             cols_to_attach = c(\"lower\", \"upper\"),                                             censor_proband_thrs = TRUE) ltfgrs_input %>% print(n = 4) #> # A tibble: 31 × 2 #>   fid   masked_fam_graph #>   <chr> <list>           #> 1 dad   <igraph>         #> 2 mom   <igraph>         #> 3 dad2  <igraph>         #> 4 mom2  <igraph>         #> # ℹ 27 more rows ltfgrs_input$masked_fam_graph[[1]] #> IGRAPH db340a9 DN-- 8 17 --  #> + attr: name (v/c), lower (v/n), upper (v/n) #> + edges from db340a9 (vertex names): #>  [1] dad   ->paunt  dad   ->puncle dad   ->sib    dad   ->pid    dad   ->phs    #>  [6] pgf   ->dad    pgf   ->paunt  pgf   ->puncle pgm   ->dad    pgm   ->paunt  #> [11] pgm   ->puncle paunt ->dad    paunt ->puncle puncle->dad    puncle->paunt  #> [16] sib   ->pid    pid   ->sib"},{"path":"https://emilmip.github.io/LTFGRS/articles/LTFGRS_workflow_prediction.html","id":"estimate-the-genetic-liability","dir":"Articles","previous_headings":"","what":"Estimate the genetic liability","title":"LTFGRS Workflow: Prepare Genetic Liability for Prediction","text":"function estimate_liability() used estimate genetic liability. function accepts two types input, focus graph-based input generated . graph-based input offer best flexibility scalability. function two arguments worth pointing . first method, specifies method used estimate genetic liability. Currently, two methods supported. first Gibbs sampler samples truncated multivariate normal distribution, method = \"Gibbs\". second iterative pearson-aitken approach, method = \"PA\". Generally speaking, Pearson-Aitken approach faster. second argument useMixture, specifies whether use mixture model . mixture model currently supported method = \"PA\". mixture model considers genetic liability controls mixture truncated normal cases controls, rather just distribution controls. accounts possibility controls undiagnosed cases accounts genetic liability estimate. using method = \"PA\", iterative conditioning performed, means resulting estimate uncertainty estimate expected mean value variance last iteration, proband’s genetic liability. highlighted use var output. using method = Gibbs, samples drawn truncated multivariate normal distribution convergence criteria met. output mean genetic liability uncertainty standard error mean. standard error denoted se column name. Noteably, uncertainties Gibbs PA methods different directly compared.","code":"ltfgrs_pa = estimate_liability(family_graphs = ltfgrs_input %>% rename(pid = fid),                                h2 = h2,                                 fid = \"fid\",                                pid = \"pid\",                                family_graphs_col = \"masked_fam_graph\",                                method = \"PA\", # <- METHOD                                useMixture = F) #> The number of workers is 1 paged_table(ltfgrs_pa) ltfgrs_gibbs = estimate_liability(family_graphs = ltfgrs_input %>% rename(pid = fid),                                    h2 = h2,                                   fid = \"fid\",                                   pid = \"pid\",                                   family_graphs_col = \"masked_fam_graph\",                                   method = \"Gibbs\", # <- METHOD                                   useMixture = F) #> The number of workers is 1 paged_table(ltfgrs_gibbs)"},{"path":"https://emilmip.github.io/LTFGRS/articles/LTFGRS_workflow_prediction.html","id":"parallelisation","dir":"Articles","previous_headings":"Estimate the genetic liability","what":"Parallelisation","title":"LTFGRS Workflow: Prepare Genetic Liability for Prediction","text":"function estimate_liability() able use future package parallelise estimation genetic liability. done setting suitable plan future backend. plan suitable needs plan(multisession, workers = NCORES), means function run parallel local PC utilising NCORES-cores. parallelisation options exist, handled future suit packages.","code":""},{"path":"https://emilmip.github.io/LTFGRS/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Emil Michael Pedersen. Author, maintainer. Jette Steinbach. Author. Lucas Rasmussen. Contributor.","code":""},{"path":"https://emilmip.github.io/LTFGRS/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pedersen E, Steinbach J (2025). LTFGRS: Implementation several phenotype-based family genetic risk scores. R package version 0.1.0, https://emilmip.github.io/LTFGRS/.","code":"@Manual{,   title = {LTFGRS: Implementation of several phenotype-based family genetic risk scores},   author = {Emil Michael Pedersen and Jette Steinbach},   year = {2025},   note = {R package version 0.1.0},   url = {https://emilmip.github.io/LTFGRS/}, }"},{"path":"https://emilmip.github.io/LTFGRS/reference/Gibbs_estimator.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrapper around the Gibbs Sampler that returns formatted liability estimates for the proband — Gibbs_estimator","title":"Wrapper around the Gibbs Sampler that returns formatted liability estimates for the proband — Gibbs_estimator","text":"Wrapper around Gibbs Sampler returns formatted liability estimates proband","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/Gibbs_estimator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrapper around the Gibbs Sampler that returns formatted liability estimates for the proband — Gibbs_estimator","text":"","code":"Gibbs_estimator(cov, tbl, out, tol = 0.01, burn_in = 1000)"},{"path":"https://emilmip.github.io/LTFGRS/reference/Gibbs_estimator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrapper around the Gibbs Sampler that returns formatted liability estimates for the proband — Gibbs_estimator","text":"cov Covariance (kinship matrix times heritability corrected diagonal) matrix tbl Tibble lower upper bounds Gibbs sampler Vector indicating genetic ans/full liabilities estimated tol Convergence criteria, tolerance burn_in Number burn-iterations","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/Gibbs_estimator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrapper around the Gibbs Sampler that returns formatted liability estimates for the proband — Gibbs_estimator","text":"Formatted liability estimate(s) standard error(s) mean proband.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/Gibbs_estimator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrapper around the Gibbs Sampler that returns formatted liability estimates for the proband — Gibbs_estimator","text":"","code":"# uninformative sampling: Gibbs_estimator(cov = diag(3), tbl = tibble::tibble(lower = rep(-Inf, 3), upper = rep(Inf, 3)), out = 1:2, tol = 0.01, burn_in = 1000) #> # A tibble: 1 × 4 #>   genetic_est genetic_se full_est full_se #>         <dbl>      <dbl>    <dbl>   <dbl> #> 1   -0.000781    0.00318  0.00394 0.00326"},{"path":"https://emilmip.github.io/LTFGRS/reference/LTFGRS-package.html","id":null,"dir":"Reference","previous_headings":"","what":"LTFGRS: Implementation of several phenotype-based family genetic risk scores — LTFGRS-package","title":"LTFGRS: Implementation of several phenotype-based family genetic risk scores — LTFGRS-package","text":"(maybe one line). Continuation lines indented.","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/reference/LTFGRS-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"LTFGRS: Implementation of several phenotype-based family genetic risk scores — LTFGRS-package","text":"Maintainer: Emil Michael Pedersen emp@ph.au.dk Authors: Jette Steinbach jst@econ.au.dk contributors: Lucas Rasmussen lar.ncrr@au.dk [contributor]","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/PA_algorithm.html","id":null,"dir":"Reference","previous_headings":"","what":"Title Pearson-Aitken algorithm to calculate mean values in truncated multivariate normal distributions — PA_algorithm","title":"Title Pearson-Aitken algorithm to calculate mean values in truncated multivariate normal distributions — PA_algorithm","text":"Title Pearson-Aitken algorithm calculate mean values truncated multivariate normal distributions","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/PA_algorithm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title Pearson-Aitken algorithm to calculate mean values in truncated multivariate normal distributions — PA_algorithm","text":"","code":"PA_algorithm(mu, covmat, target_id, lower, upper, K_i = NA, K_pop = NA)"},{"path":"https://emilmip.github.io/LTFGRS/reference/PA_algorithm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title Pearson-Aitken algorithm to calculate mean values in truncated multivariate normal distributions — PA_algorithm","text":"mu vector means covmat covariance matrix, contaning kinship coefficient heritability entry (except diagnoal, 1 full liabilities h2 genetic liabilities) target_id ID target individual (genetic liability), .e. rowname covmat return expected genetic liability lower vector lower thresholds upper vector upper thresholds K_i vector stratified CIPs individual. used estimating genetic liability mixture model. K_pop vector population CIPs. used estimating genetic liability mixture model.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/PA_algorithm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title Pearson-Aitken algorithm to calculate mean values in truncated multivariate normal distributions — PA_algorithm","text":"list two elements: est (expected genetic liability, given input data) var (variance genetic liability, given input data).","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/attach_attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Attach attributes to a family graphs — attach_attributes","title":"Attach attributes to a family graphs — attach_attributes","text":"function attaches attributes family graphs, lower upper thresholds, family member. allows user-friendly way attach personalised thresholds per-family specific attributes family graphs.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/attach_attributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attach attributes to a family graphs — attach_attributes","text":"","code":"attach_attributes(   cur_fam_graph,   cur_proband,   fid,   attr_tbl,   attr_names,   censor_proband_thrs = TRUE )"},{"path":"https://emilmip.github.io/LTFGRS/reference/attach_attributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attach attributes to a family graphs — attach_attributes","text":"cur_fam_graph igraph object (neighbourhood graph around proband) family members degree n. cur_proband Current proband id (center neighbourhood graph). fid Column name family id. attr_tbl Tibble family id attributes family member. attr_names Names attributes assigned node (family member) graph. censor_proband_thrs proband's upper lower thresholds made uninformative? Defaults TRUE. Used exclude proband's information prediction.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/attach_attributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attach attributes to a family graphs — attach_attributes","text":"igraph object (neighbourhood graph around proband) updated attributes node graph.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/censor_family_onsets.html","id":null,"dir":"Reference","previous_headings":"","what":"Censor onset times in a family based on a proband's end of follow-up. — censor_family_onsets","title":"Censor onset times in a family based on a proband's end of follow-up. — censor_family_onsets","text":"function censors onset times family members based proband's end follow-. done prevent using future events base predictions .","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/censor_family_onsets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Censor onset times in a family based on a proband's end of follow-up. — censor_family_onsets","text":"","code":"censor_family_onsets(   tbl,   proband_id_col,   cur_proband,   start,   end,   event,   status_col = \"status\",   aod_col = \"aod\",   age_eof_col = \"age\" )"},{"path":"https://emilmip.github.io/LTFGRS/reference/censor_family_onsets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Censor onset times in a family based on a proband's end of follow-up. — censor_family_onsets","text":"tbl tibble info family members, censoring events based cur_proband proband_id_col, must contain start, end, event columns proband_id_col column name proband ids within family cur_proband current proband id start start follow , typically birth date, must date column end end follow , must date column event event interest, typically date diagnosis, must date column status_col column name status column created. Defaults \"status. aod_col column name age diagnosis (aod) column created. Defaults \"aod\". age_eof_col column name age end follow-(eof) column created. Defaults \"age_eof\".","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/censor_family_onsets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Censor onset times in a family based on a proband's end of follow-up. — censor_family_onsets","text":"tibble updated end times, status, age diagnosis, age end follow-family, proband's end time used end time family members. prevents  using future events based predictions .","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/censor_family_onsets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Censor onset times in a family based on a proband's end of follow-up. — censor_family_onsets","text":"","code":"# See Vignettes."},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructing a covariance matrix for a variable number of phenotypes — construct_covmat","title":"Constructing a covariance matrix for a variable number of phenotypes — construct_covmat","text":"construct_covmat returns covariance matrix underlying target individual variable number family members variable number phenotypes. wrapper around construct_covmat_single construct_covmat_multi.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructing a covariance matrix for a variable number of phenotypes — construct_covmat","text":"","code":"construct_covmat(   fam_vec = c(\"m\", \"f\", \"s1\", \"mgm\", \"mgf\", \"pgm\", \"pgf\"),   n_fam = NULL,   add_ind = TRUE,   h2 = 0.5,   genetic_corrmat = NULL,   full_corrmat = NULL,   phen_names = NULL )"},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructing a covariance matrix for a variable number of phenotypes — construct_covmat","text":"fam_vec vector strings holding different family members. family members must represented strings following list: - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side).  Defaults c(\"m\",\"f\",\"s1\",\"mgm\",\"mgf\",\"pgm\",\"pgf\"). n_fam named vector holding desired number family members. See setNames. names must picked list mentioned . Defaults NULL. add_ind logical scalar indicating whether genetic component full liability well full liability underlying individual included covariance matrix. Defaults TRUE. h2 Either number representing heritability liability scale one single phenotype numeric vector representing liability-scale heritabilities positive number phenotypes. entries h2 must non-negative 1. genetic_corrmat Either NULL numeric matrix holding genetic correlations desired phenotypes. diagonal entries must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. Defaults NULL. full_corrmat Either NULL  numeric matrix holding full correlations desired phenotypes. diagonal entries must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. Defaults NULL. phen_names Either NULL character vector holding phenotype names. names used create row column names covariance matrix. specified, names default phenotype1, phenotype2, etc. Defaults NULL.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructing a covariance matrix for a variable number of phenotypes — construct_covmat","text":"either fam_vec n_fam used argument, required format, add_ind logical scalar h2 number satisfying $$0 \\leq h2 \\leq 1$$, function construct_covmat return named covariance matrix, row- column-number corresponds length fam_vec n_fam (+ 2 add_ind=TRUE). However, h2 numeric vector satisfying $$0 \\leq h2_i \\leq 1$$ $$\\\\{1,...,n_pheno\\}$$ genetic_corrmat full_corrmat two numeric symmetric matrices satisfying diagonal entries one -diagonal entries -1 1, construct_covmat return named covariance matrix, number rows columns corresponds number phenotypes times length fam_vec n_fam (+ 2 add_ind=TRUE). fam_vec n_fam equal c() NULL, function returns either \\(2 \\times 2\\) matrix holding correlation genetic component full liability full liability individual consideration, $$(2 \\times n_pheno) \\times (2\\times n_pheno)$$ matrix holding correlation genetic component full liability full liability underlying individual phenotypes. fam_vec n_fam specified, user asked decide two vectors use. Note returned object different attributes, fam_vec, n_fam, add_ind h2.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructing a covariance matrix for a variable number of phenotypes — construct_covmat","text":"function can used construct covariance matrix given number family members. h2 number, entry covariance matrix equals percentage shared DNA corresponding individuals times liability-scale heritability $$h^2$$. However, h2 numeric vector, genetic_corrmat full_corrmat two symmetric correlation matrices, entry equals either percentage shared DNA corresponding individuals times liability-scale heritability $$h^2$$ percentage shared DNA corresponding individuals times correlation corresponding phenotypes. family members can specified using one two possible formats.","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructing a covariance matrix for a variable number of phenotypes — construct_covmat","text":"","code":"construct_covmat() #>         g     o    m    f    s1   mgm   mgf   pgm   pgf #> g   0.500 0.500 0.25 0.25 0.250 0.125 0.125 0.125 0.125 #> o   0.500 1.000 0.25 0.25 0.250 0.125 0.125 0.125 0.125 #> m   0.250 0.250 1.00 0.00 0.250 0.250 0.250 0.000 0.000 #> f   0.250 0.250 0.00 1.00 0.250 0.000 0.000 0.250 0.250 #> s1  0.250 0.250 0.25 0.25 1.000 0.125 0.125 0.125 0.125 #> mgm 0.125 0.125 0.25 0.00 0.125 1.000 0.000 0.000 0.000 #> mgf 0.125 0.125 0.25 0.00 0.125 0.000 1.000 0.000 0.000 #> pgm 0.125 0.125 0.00 0.25 0.125 0.000 0.000 1.000 0.000 #> pgf 0.125 0.125 0.00 0.25 0.125 0.000 0.000 0.000 1.000 #> attr(,\"fam_vec\") #> [1] \"g\"   \"o\"   \"m\"   \"f\"   \"s1\"  \"mgm\" \"mgf\" \"pgm\" \"pgf\" #> attr(,\"n_fam\") #>  #>   f   g   m mgf mgm   o pgf pgm   s  #>   1   1   1   1   1   1   1   1   1  #> attr(,\"add_ind\") #> [1] TRUE #> attr(,\"h2\") #> [1] 0.5 construct_covmat(fam_vec = c(\"m\",\"mgm\",\"mgf\",\"mhs1\",\"mhs2\",\"mau1\"),                  n_fam = NULL,                  add_ind = TRUE,                  h2 = 0.5) #>          g     o    m   mgm   mgf  mhs1  mhs2  mau1 #> g    0.500 0.500 0.25 0.125 0.125 0.125 0.125 0.125 #> o    0.500 1.000 0.25 0.125 0.125 0.125 0.125 0.125 #> m    0.250 0.250 1.00 0.250 0.250 0.250 0.250 0.250 #> mgm  0.125 0.125 0.25 1.000 0.000 0.125 0.125 0.250 #> mgf  0.125 0.125 0.25 0.000 1.000 0.125 0.125 0.250 #> mhs1 0.125 0.125 0.25 0.125 0.125 1.000 0.250 0.125 #> mhs2 0.125 0.125 0.25 0.125 0.125 0.250 1.000 0.125 #> mau1 0.125 0.125 0.25 0.250 0.250 0.125 0.125 1.000 #> attr(,\"fam_vec\") #> [1] \"g\"    \"o\"    \"m\"    \"mgm\"  \"mgf\"  \"mhs1\" \"mhs2\" \"mau1\" #> attr(,\"n_fam\") #>  #>   g   m mau mgf mgm mhs   o  #>   1   1   1   1   1   2   1  #> attr(,\"add_ind\") #> [1] TRUE #> attr(,\"h2\") #> [1] 0.5 construct_covmat(fam_vec = NULL,                  n_fam = stats::setNames(c(1,1,1,2,2), c(\"m\",\"mgm\",\"mgf\",\"s\",\"mhs\")),                  add_ind = FALSE,                  h2 = 0.3) #>         m   mgm   mgf    s1    s2  mhs1  mhs2 #> m    1.00 0.150 0.150 0.150 0.150 0.150 0.150 #> mgm  0.15 1.000 0.000 0.075 0.075 0.075 0.075 #> mgf  0.15 0.000 1.000 0.075 0.075 0.075 0.075 #> s1   0.15 0.075 0.075 1.000 0.150 0.075 0.075 #> s2   0.15 0.075 0.075 0.150 1.000 0.075 0.075 #> mhs1 0.15 0.075 0.075 0.075 0.075 1.000 0.150 #> mhs2 0.15 0.075 0.075 0.075 0.075 0.150 1.000 #> attr(,\"fam_vec\") #> [1] \"m\"    \"mgm\"  \"mgf\"  \"s1\"   \"s2\"   \"mhs1\" \"mhs2\" #> attr(,\"n_fam\") #>   m mgm mgf   s mhs  #>   1   1   1   2   2  #> attr(,\"add_ind\") #> [1] FALSE #> attr(,\"h2\") #> [1] 0.3 construct_covmat(h2 = c(0.5,0.5), genetic_corrmat = matrix(c(1,0.4,0.4,1), nrow = 2),                  full_corrmat = matrix(c(1,0.6,0.6,1), nrow = 2)) #>                g_phenotype1 o_phenotype1 m_phenotype1 f_phenotype1 #> g_phenotype1          0.500        0.500         0.25         0.25 #> o_phenotype1          0.500        1.000         0.25         0.25 #> m_phenotype1          0.250        0.250         1.00         0.00 #> f_phenotype1          0.250        0.250         0.00         1.00 #> s1_phenotype1         0.250        0.250         0.25         0.25 #> mgm_phenotype1        0.125        0.125         0.25         0.00 #> mgf_phenotype1        0.125        0.125         0.25         0.00 #> pgm_phenotype1        0.125        0.125         0.00         0.25 #> pgf_phenotype1        0.125        0.125         0.00         0.25 #> g_phenotype2          0.200        0.200         0.10         0.10 #> o_phenotype2          0.200        0.600         0.10         0.10 #> m_phenotype2          0.100        0.100         0.60         0.00 #> f_phenotype2          0.100        0.100         0.00         0.60 #> s1_phenotype2         0.100        0.100         0.10         0.10 #> mgm_phenotype2        0.050        0.050         0.10         0.00 #> mgf_phenotype2        0.050        0.050         0.10         0.00 #> pgm_phenotype2        0.050        0.050         0.00         0.10 #> pgf_phenotype2        0.050        0.050         0.00         0.10 #>                s1_phenotype1 mgm_phenotype1 mgf_phenotype1 pgm_phenotype1 #> g_phenotype1           0.250          0.125          0.125          0.125 #> o_phenotype1           0.250          0.125          0.125          0.125 #> m_phenotype1           0.250          0.250          0.250          0.000 #> f_phenotype1           0.250          0.000          0.000          0.250 #> s1_phenotype1          1.000          0.125          0.125          0.125 #> mgm_phenotype1         0.125          1.000          0.000          0.000 #> mgf_phenotype1         0.125          0.000          1.000          0.000 #> pgm_phenotype1         0.125          0.000          0.000          1.000 #> pgf_phenotype1         0.125          0.000          0.000          0.000 #> g_phenotype2           0.100          0.050          0.050          0.050 #> o_phenotype2           0.100          0.050          0.050          0.050 #> m_phenotype2           0.100          0.100          0.100          0.000 #> f_phenotype2           0.100          0.000          0.000          0.100 #> s1_phenotype2          0.600          0.050          0.050          0.050 #> mgm_phenotype2         0.050          0.600          0.000          0.000 #> mgf_phenotype2         0.050          0.000          0.600          0.000 #> pgm_phenotype2         0.050          0.000          0.000          0.600 #> pgf_phenotype2         0.050          0.000          0.000          0.000 #>                pgf_phenotype1 g_phenotype2 o_phenotype2 m_phenotype2 #> g_phenotype1            0.125        0.200        0.200         0.10 #> o_phenotype1            0.125        0.200        0.600         0.10 #> m_phenotype1            0.000        0.100        0.100         0.60 #> f_phenotype1            0.250        0.100        0.100         0.00 #> s1_phenotype1           0.125        0.100        0.100         0.10 #> mgm_phenotype1          0.000        0.050        0.050         0.10 #> mgf_phenotype1          0.000        0.050        0.050         0.10 #> pgm_phenotype1          0.000        0.050        0.050         0.00 #> pgf_phenotype1          1.000        0.050        0.050         0.00 #> g_phenotype2            0.050        0.500        0.500         0.25 #> o_phenotype2            0.050        0.500        1.000         0.25 #> m_phenotype2            0.000        0.250        0.250         1.00 #> f_phenotype2            0.100        0.250        0.250         0.00 #> s1_phenotype2           0.050        0.250        0.250         0.25 #> mgm_phenotype2          0.000        0.125        0.125         0.25 #> mgf_phenotype2          0.000        0.125        0.125         0.25 #> pgm_phenotype2          0.000        0.125        0.125         0.00 #> pgf_phenotype2          0.600        0.125        0.125         0.00 #>                f_phenotype2 s1_phenotype2 mgm_phenotype2 mgf_phenotype2 #> g_phenotype1           0.10         0.100          0.050          0.050 #> o_phenotype1           0.10         0.100          0.050          0.050 #> m_phenotype1           0.00         0.100          0.100          0.100 #> f_phenotype1           0.60         0.100          0.000          0.000 #> s1_phenotype1          0.10         0.600          0.050          0.050 #> mgm_phenotype1         0.00         0.050          0.600          0.000 #> mgf_phenotype1         0.00         0.050          0.000          0.600 #> pgm_phenotype1         0.10         0.050          0.000          0.000 #> pgf_phenotype1         0.10         0.050          0.000          0.000 #> g_phenotype2           0.25         0.250          0.125          0.125 #> o_phenotype2           0.25         0.250          0.125          0.125 #> m_phenotype2           0.00         0.250          0.250          0.250 #> f_phenotype2           1.00         0.250          0.000          0.000 #> s1_phenotype2          0.25         1.000          0.125          0.125 #> mgm_phenotype2         0.00         0.125          1.000          0.000 #> mgf_phenotype2         0.00         0.125          0.000          1.000 #> pgm_phenotype2         0.25         0.125          0.000          0.000 #> pgf_phenotype2         0.25         0.125          0.000          0.000 #>                pgm_phenotype2 pgf_phenotype2 #> g_phenotype1            0.050          0.050 #> o_phenotype1            0.050          0.050 #> m_phenotype1            0.000          0.000 #> f_phenotype1            0.100          0.100 #> s1_phenotype1           0.050          0.050 #> mgm_phenotype1          0.000          0.000 #> mgf_phenotype1          0.000          0.000 #> pgm_phenotype1          0.600          0.000 #> pgf_phenotype1          0.000          0.600 #> g_phenotype2            0.125          0.125 #> o_phenotype2            0.125          0.125 #> m_phenotype2            0.000          0.000 #> f_phenotype2            0.250          0.250 #> s1_phenotype2           0.125          0.125 #> mgm_phenotype2          0.000          0.000 #> mgf_phenotype2          0.000          0.000 #> pgm_phenotype2          1.000          0.000 #> pgf_phenotype2          0.000          1.000 #> attr(,\"fam_vec\") #> [1] \"g\"   \"o\"   \"m\"   \"f\"   \"s1\"  \"mgm\" \"mgf\" \"pgm\" \"pgf\" #> attr(,\"n_fam\") #>  #>   f   g   m mgf mgm   o pgf pgm   s  #>   1   1   1   1   1   1   1   1   1  #> attr(,\"add_ind\") #> [1] TRUE #> attr(,\"h2\") #> [1] 0.5 0.5 #> attr(,\"genetic_corrmat\") #>      [,1] [,2] #> [1,]  1.0  0.4 #> [2,]  0.4  1.0 #> attr(,\"full_corrmat\") #>      [,1] [,2] #> [1,]  1.0  0.6 #> [2,]  0.6  1.0 #> attr(,\"phenotype_names\") #> [1] \"phenotype1\" \"phenotype2\""},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructing a covariance matrix for multiple phenotypes — construct_covmat_multi","title":"Constructing a covariance matrix for multiple phenotypes — construct_covmat_multi","text":"construct_covmat_multi returns covariance matrix underlying target individual variable number family members multiple phenotypes.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructing a covariance matrix for multiple phenotypes — construct_covmat_multi","text":"","code":"construct_covmat_multi(   fam_vec = c(\"m\", \"f\", \"s1\", \"mgm\", \"mgf\", \"pgm\", \"pgf\"),   n_fam = NULL,   add_ind = TRUE,   genetic_corrmat,   full_corrmat,   h2_vec,   phen_names = NULL )"},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructing a covariance matrix for multiple phenotypes — construct_covmat_multi","text":"fam_vec vector strings holding different family members. family members must represented strings following list: - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side).  Defaults c(\"m\",\"f\",\"s1\",\"mgm\",\"mgf\",\"pgm\",\"pgf\"). n_fam named vector holding desired number family members. See setNames. names must picked list mentioned . Defaults NULL. add_ind logical scalar indicating whether genetic component full liability well full liability underlying individual included covariance matrix. Defaults TRUE. genetic_corrmat numeric matrix holding genetic correlations desired phenotypes. diagonal entries must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. full_corrmat numeric matrix holding full correlations desired phenotypes. diagonal entries must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. h2_vec numeric vector representing liability-scale heritabilities phenotypes. entries h2_vec must non-negative 1. phen_names character vector holding phenotype names. names used create row column names covariance matrix. specified, names default phenotype1, phenotype2, etc. Defaults NULL.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_multi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructing a covariance matrix for multiple phenotypes — construct_covmat_multi","text":"either fam_vec n_fam used argument required format, genetic_corrmat full_corrmat two numeric symmetric matrices satisfying diagonal entries one -diagonal entries -1 1, h2_vec numeric vector satisfying \\(0 \\leq h2_i \\leq 1\\) \\(\\\\{1,...,n_pheno\\}\\), output named covariance matrix. number rows columns corresponds number phenotypes times length fam_vec n_fam (+ 2 add_ind=TRUE). fam_vec n_fam equal c() NULL, function returns \\((2 \\times n_pheno) \\times (2\\times n_pheno)\\) matrix holding correlation genetic component full liability full liability underlying individual phenotypes. fam_vec n_fam specified, user asked decide two vectors use. Note returned object number different attributes,namely fam_vec, n_fam, add_ind, genetic_corrmat, full_corrmat, h2 phenotype_names.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_multi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructing a covariance matrix for multiple phenotypes — construct_covmat_multi","text":"function can used construct covariance matrix given number family members. entry covariance matrix equals either percentage shared DNA corresponding individuals times liability-scale heritability \\(h^2\\) percentage shared DNA corresponding individuals times correlation corresponding phenotypes. , phenotype, covariance combinations genetic component full liability full liability given $$\\text{Cov}\\left( l_g, l_g \\right) = h^2,$$ $$\\text{Cov}\\left( l_g, l_o \\right) = h^2,$$ $$\\text{Cov}\\left( l_o, l_g \\right) = h^2$$ $$\\text{Cov}\\left( l_o, l_o \\right) = 1.$$ two different phenotypes, covariance given $$\\text{Cov}\\left( l_g^1, l_g^2 \\right) = \\rho_g^{1,2},$$ $$\\text{Cov}\\left( l_g^1, l_o^2 \\right) = \\rho_g^{1,2},$$ $$\\text{Cov}\\left( l_o^1, l_g^2 \\right) = \\rho_g^{1,2}$$ $$\\text{Cov}\\left( l_o^1, l_o^2 \\right) = \\rho_g^{1,2} + \\rho_e^{1,2},$$ \\(l_g^\\) \\(l_o^\\) genetic component full liability full liability phenotype \\(\\), respectively, \\(\\rho_g^{,j}\\) genetic correlation phenotype \\(\\) \\(j\\) \\(\\rho_e^{1,2}\\) environmental correlation phenotype \\(\\) \\(j\\). family members can specified using one two possible formats.","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_multi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructing a covariance matrix for multiple phenotypes — construct_covmat_multi","text":"","code":"construct_covmat_multi(fam_vec = NULL,                        genetic_corrmat = matrix(c(1, 0.5, 0.5, 1), nrow = 2),                        full_corrmat = matrix(c(1, 0.55, 0.55, 1), nrow = 2),                        h2_vec = c(0.37,0.44),                        phen_names = c(\"p1\",\"p2\")) #> Warning:  #>  Neither fam_vec nor n_fam is specified... #>      g_p1 o_p1 g_p2 o_p2 #> g_p1 0.37 0.37 0.50 0.50 #> o_p1 0.37 1.00 0.50 0.55 #> g_p2 0.50 0.50 0.44 0.44 #> o_p2 0.50 0.55 0.44 1.00 #> attr(,\"fam_vec\") #> [1] \"g\" \"o\" #> attr(,\"n_fam\") #> g o  #> 1 1  #> attr(,\"add_ind\") #> [1] TRUE #> attr(,\"h2\") #> [1] 0.37 0.44 #> attr(,\"genetic_corrmat\") #>      [,1] [,2] #> [1,]  1.0  0.5 #> [2,]  0.5  1.0 #> attr(,\"full_corrmat\") #>      [,1] [,2] #> [1,] 1.00 0.55 #> [2,] 0.55 1.00 #> attr(,\"phenotype_names\") #> [1] \"p1\" \"p2\" construct_covmat_multi(fam_vec = c(\"m\",\"mgm\",\"mgf\",\"mhs1\",\"mhs2\",\"mau1\"),                        n_fam = NULL,                        add_ind = TRUE,                        genetic_corrmat = diag(3),                        full_corrmat = diag(3),                        h2_vec = c(0.8, 0.65)) #>                 g_phenotype1 o_phenotype1 m_phenotype1 mgm_phenotype1 #> g_phenotype1             0.8          0.8          0.4            0.2 #> o_phenotype1             0.8          1.0          0.4            0.2 #> m_phenotype1             0.4          0.4          1.0            0.4 #> mgm_phenotype1           0.2          0.2          0.4            1.0 #> mgf_phenotype1           0.2          0.2          0.4            0.0 #> mhs1_phenotype1          0.2          0.2          0.4            0.2 #> mhs2_phenotype1          0.2          0.2          0.4            0.2 #> mau1_phenotype1          0.2          0.2          0.4            0.4 #> g_phenotype2             0.0          0.0          0.0            0.0 #> o_phenotype2             0.0          0.0          0.0            0.0 #> m_phenotype2             0.0          0.0          0.0            0.0 #> mgm_phenotype2           0.0          0.0          0.0            0.0 #> mgf_phenotype2           0.0          0.0          0.0            0.0 #> mhs1_phenotype2          0.0          0.0          0.0            0.0 #> mhs2_phenotype2          0.0          0.0          0.0            0.0 #> mau1_phenotype2          0.0          0.0          0.0            0.0 #>                 mgf_phenotype1 mhs1_phenotype1 mhs2_phenotype1 mau1_phenotype1 #> g_phenotype1               0.2             0.2             0.2             0.2 #> o_phenotype1               0.2             0.2             0.2             0.2 #> m_phenotype1               0.4             0.4             0.4             0.4 #> mgm_phenotype1             0.0             0.2             0.2             0.4 #> mgf_phenotype1             1.0             0.2             0.2             0.4 #> mhs1_phenotype1            0.2             1.0             0.4             0.2 #> mhs2_phenotype1            0.2             0.4             1.0             0.2 #> mau1_phenotype1            0.4             0.2             0.2             1.0 #> g_phenotype2               0.0             0.0             0.0             0.0 #> o_phenotype2               0.0             0.0             0.0             0.0 #> m_phenotype2               0.0             0.0             0.0             0.0 #> mgm_phenotype2             0.0             0.0             0.0             0.0 #> mgf_phenotype2             0.0             0.0             0.0             0.0 #> mhs1_phenotype2            0.0             0.0             0.0             0.0 #> mhs2_phenotype2            0.0             0.0             0.0             0.0 #> mau1_phenotype2            0.0             0.0             0.0             0.0 #>                 g_phenotype2 o_phenotype2 m_phenotype2 mgm_phenotype2 #> g_phenotype1          0.0000       0.0000        0.000         0.0000 #> o_phenotype1          0.0000       0.0000        0.000         0.0000 #> m_phenotype1          0.0000       0.0000        0.000         0.0000 #> mgm_phenotype1        0.0000       0.0000        0.000         0.0000 #> mgf_phenotype1        0.0000       0.0000        0.000         0.0000 #> mhs1_phenotype1       0.0000       0.0000        0.000         0.0000 #> mhs2_phenotype1       0.0000       0.0000        0.000         0.0000 #> mau1_phenotype1       0.0000       0.0000        0.000         0.0000 #> g_phenotype2          0.6500       0.6500        0.325         0.1625 #> o_phenotype2          0.6500       1.0000        0.325         0.1625 #> m_phenotype2          0.3250       0.3250        1.000         0.3250 #> mgm_phenotype2        0.1625       0.1625        0.325         1.0000 #> mgf_phenotype2        0.1625       0.1625        0.325         0.0000 #> mhs1_phenotype2       0.1625       0.1625        0.325         0.1625 #> mhs2_phenotype2       0.1625       0.1625        0.325         0.1625 #> mau1_phenotype2       0.1625       0.1625        0.325         0.3250 #>                 mgf_phenotype2 mhs1_phenotype2 mhs2_phenotype2 mau1_phenotype2 #> g_phenotype1            0.0000          0.0000          0.0000          0.0000 #> o_phenotype1            0.0000          0.0000          0.0000          0.0000 #> m_phenotype1            0.0000          0.0000          0.0000          0.0000 #> mgm_phenotype1          0.0000          0.0000          0.0000          0.0000 #> mgf_phenotype1          0.0000          0.0000          0.0000          0.0000 #> mhs1_phenotype1         0.0000          0.0000          0.0000          0.0000 #> mhs2_phenotype1         0.0000          0.0000          0.0000          0.0000 #> mau1_phenotype1         0.0000          0.0000          0.0000          0.0000 #> g_phenotype2            0.1625          0.1625          0.1625          0.1625 #> o_phenotype2            0.1625          0.1625          0.1625          0.1625 #> m_phenotype2            0.3250          0.3250          0.3250          0.3250 #> mgm_phenotype2          0.0000          0.1625          0.1625          0.3250 #> mgf_phenotype2          1.0000          0.1625          0.1625          0.3250 #> mhs1_phenotype2         0.1625          1.0000          0.3250          0.1625 #> mhs2_phenotype2         0.1625          0.3250          1.0000          0.1625 #> mau1_phenotype2         0.3250          0.1625          0.1625          1.0000 #> attr(,\"fam_vec\") #> [1] \"g\"    \"o\"    \"m\"    \"mgm\"  \"mgf\"  \"mhs1\" \"mhs2\" \"mau1\" #> attr(,\"n_fam\") #>  #>   g   m mau mgf mgm mhs   o  #>   1   1   1   1   1   2   1  #> attr(,\"add_ind\") #> [1] TRUE #> attr(,\"h2\") #> [1] 0.80 0.65 #> attr(,\"genetic_corrmat\") #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1 #> attr(,\"full_corrmat\") #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1 #> attr(,\"phenotype_names\") #> [1] \"phenotype1\" \"phenotype2\" construct_covmat_multi(fam_vec = NULL,                        n_fam = stats::setNames(c(1,1,1,2,2), c(\"m\",\"mgm\",\"mgf\",\"s\",\"mhs\")),                        add_ind = FALSE,                        genetic_corrmat = diag(2),                        full_corrmat = diag(2),                        h2_vec = c(0.75,0.85)) #>                 m_phenotype1 mgm_phenotype1 mgf_phenotype1 s1_phenotype1 #> m_phenotype1           1.000         0.3750         0.3750        0.3750 #> mgm_phenotype1         0.375         1.0000         0.0000        0.1875 #> mgf_phenotype1         0.375         0.0000         1.0000        0.1875 #> s1_phenotype1          0.375         0.1875         0.1875        1.0000 #> s2_phenotype1          0.375         0.1875         0.1875        0.3750 #> mhs1_phenotype1        0.375         0.1875         0.1875        0.1875 #> mhs2_phenotype1        0.375         0.1875         0.1875        0.1875 #> m_phenotype2           0.000         0.0000         0.0000        0.0000 #> mgm_phenotype2         0.000         0.0000         0.0000        0.0000 #> mgf_phenotype2         0.000         0.0000         0.0000        0.0000 #> s1_phenotype2          0.000         0.0000         0.0000        0.0000 #> s2_phenotype2          0.000         0.0000         0.0000        0.0000 #> mhs1_phenotype2        0.000         0.0000         0.0000        0.0000 #> mhs2_phenotype2        0.000         0.0000         0.0000        0.0000 #>                 s2_phenotype1 mhs1_phenotype1 mhs2_phenotype1 m_phenotype2 #> m_phenotype1           0.3750          0.3750          0.3750        0.000 #> mgm_phenotype1         0.1875          0.1875          0.1875        0.000 #> mgf_phenotype1         0.1875          0.1875          0.1875        0.000 #> s1_phenotype1          0.3750          0.1875          0.1875        0.000 #> s2_phenotype1          1.0000          0.1875          0.1875        0.000 #> mhs1_phenotype1        0.1875          1.0000          0.3750        0.000 #> mhs2_phenotype1        0.1875          0.3750          1.0000        0.000 #> m_phenotype2           0.0000          0.0000          0.0000        1.000 #> mgm_phenotype2         0.0000          0.0000          0.0000        0.425 #> mgf_phenotype2         0.0000          0.0000          0.0000        0.425 #> s1_phenotype2          0.0000          0.0000          0.0000        0.425 #> s2_phenotype2          0.0000          0.0000          0.0000        0.425 #> mhs1_phenotype2        0.0000          0.0000          0.0000        0.425 #> mhs2_phenotype2        0.0000          0.0000          0.0000        0.425 #>                 mgm_phenotype2 mgf_phenotype2 s1_phenotype2 s2_phenotype2 #> m_phenotype1            0.0000         0.0000        0.0000        0.0000 #> mgm_phenotype1          0.0000         0.0000        0.0000        0.0000 #> mgf_phenotype1          0.0000         0.0000        0.0000        0.0000 #> s1_phenotype1           0.0000         0.0000        0.0000        0.0000 #> s2_phenotype1           0.0000         0.0000        0.0000        0.0000 #> mhs1_phenotype1         0.0000         0.0000        0.0000        0.0000 #> mhs2_phenotype1         0.0000         0.0000        0.0000        0.0000 #> m_phenotype2            0.4250         0.4250        0.4250        0.4250 #> mgm_phenotype2          1.0000         0.0000        0.2125        0.2125 #> mgf_phenotype2          0.0000         1.0000        0.2125        0.2125 #> s1_phenotype2           0.2125         0.2125        1.0000        0.4250 #> s2_phenotype2           0.2125         0.2125        0.4250        1.0000 #> mhs1_phenotype2         0.2125         0.2125        0.2125        0.2125 #> mhs2_phenotype2         0.2125         0.2125        0.2125        0.2125 #>                 mhs1_phenotype2 mhs2_phenotype2 #> m_phenotype1             0.0000          0.0000 #> mgm_phenotype1           0.0000          0.0000 #> mgf_phenotype1           0.0000          0.0000 #> s1_phenotype1            0.0000          0.0000 #> s2_phenotype1            0.0000          0.0000 #> mhs1_phenotype1          0.0000          0.0000 #> mhs2_phenotype1          0.0000          0.0000 #> m_phenotype2             0.4250          0.4250 #> mgm_phenotype2           0.2125          0.2125 #> mgf_phenotype2           0.2125          0.2125 #> s1_phenotype2            0.2125          0.2125 #> s2_phenotype2            0.2125          0.2125 #> mhs1_phenotype2          1.0000          0.4250 #> mhs2_phenotype2          0.4250          1.0000 #> attr(,\"fam_vec\") #> [1] \"m\"    \"mgm\"  \"mgf\"  \"s1\"   \"s2\"   \"mhs1\" \"mhs2\" #> attr(,\"n_fam\") #>   m mgm mgf   s mhs  #>   1   1   1   2   2  #> attr(,\"add_ind\") #> [1] FALSE #> attr(,\"h2\") #> [1] 0.75 0.85 #> attr(,\"genetic_corrmat\") #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #> attr(,\"full_corrmat\") #>      [,1] [,2] #> [1,]    1    0 #> [2,]    0    1 #> attr(,\"phenotype_names\") #> [1] \"phenotype1\" \"phenotype2\""},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructing a covariance matrix for a single phenotype — construct_covmat_single","title":"Constructing a covariance matrix for a single phenotype — construct_covmat_single","text":"construct_covmatc_single returns covariance matrix underlying target individual variable number family members","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructing a covariance matrix for a single phenotype — construct_covmat_single","text":"","code":"construct_covmat_single(   fam_vec = c(\"m\", \"f\", \"s1\", \"mgm\", \"mgf\", \"pgm\", \"pgf\"),   n_fam = NULL,   add_ind = TRUE,   h2 = 0.5 )"},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructing a covariance matrix for a single phenotype — construct_covmat_single","text":"fam_vec vector strings holding different family members. family members must represented strings following list: - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side). n_fam named vector holding desired number family members. See setNames. names must picked list mentioned . Defaults NULL. add_ind logical scalar indicating whether genetic component full liability well full liability underlying individual included covariance matrix. Defaults TRUE. h2 number representing squared heritability liability scale single phenotype. Must non-negative 1. Defaults 0.5.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructing a covariance matrix for a single phenotype — construct_covmat_single","text":"either fam_vec n_fam used argument, required format h2 number satisfying \\(0 \\leq h2 \\leq 1\\), output named covariance matrix. number rows columns corresponds length fam_vec n_fam (+ 2 add_ind=TRUE). fam_vec = c()/NULL n_fam = c()/NULL, function returns \\(2 \\times 2\\) matrix holding correlation genetic component full liability full liability individual. fam_vec n_fam given, user asked decide two vectors use. Note returned object different attributes, fam_vec, n_fam, add_ind h2.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_single.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constructing a covariance matrix for a single phenotype — construct_covmat_single","text":"function can used construct covariance matrix given number family members. entry covariance matrix equals percentage shared DNA corresponding individuals times liability-scale heritability \\(h^2\\). family members can specified using one two possible formats.","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/reference/construct_covmat_single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructing a covariance matrix for a single phenotype — construct_covmat_single","text":"","code":"construct_covmat_single() #>         g     o    m    f    s1   mgm   mgf   pgm   pgf #> g   0.500 0.500 0.25 0.25 0.250 0.125 0.125 0.125 0.125 #> o   0.500 1.000 0.25 0.25 0.250 0.125 0.125 0.125 0.125 #> m   0.250 0.250 1.00 0.00 0.250 0.250 0.250 0.000 0.000 #> f   0.250 0.250 0.00 1.00 0.250 0.000 0.000 0.250 0.250 #> s1  0.250 0.250 0.25 0.25 1.000 0.125 0.125 0.125 0.125 #> mgm 0.125 0.125 0.25 0.00 0.125 1.000 0.000 0.000 0.000 #> mgf 0.125 0.125 0.25 0.00 0.125 0.000 1.000 0.000 0.000 #> pgm 0.125 0.125 0.00 0.25 0.125 0.000 0.000 1.000 0.000 #> pgf 0.125 0.125 0.00 0.25 0.125 0.000 0.000 0.000 1.000 #> attr(,\"fam_vec\") #> [1] \"g\"   \"o\"   \"m\"   \"f\"   \"s1\"  \"mgm\" \"mgf\" \"pgm\" \"pgf\" #> attr(,\"n_fam\") #>  #>   f   g   m mgf mgm   o pgf pgm   s  #>   1   1   1   1   1   1   1   1   1  #> attr(,\"add_ind\") #> [1] TRUE #> attr(,\"h2\") #> [1] 0.5 construct_covmat_single(fam_vec = c(\"m\",\"mgm\",\"mgf\",\"mhs1\",\"mhs2\",\"mau1\"), n_fam = NULL, add_ind = TRUE, h2 = 0.5) #>          g     o    m   mgm   mgf  mhs1  mhs2  mau1 #> g    0.500 0.500 0.25 0.125 0.125 0.125 0.125 0.125 #> o    0.500 1.000 0.25 0.125 0.125 0.125 0.125 0.125 #> m    0.250 0.250 1.00 0.250 0.250 0.250 0.250 0.250 #> mgm  0.125 0.125 0.25 1.000 0.000 0.125 0.125 0.250 #> mgf  0.125 0.125 0.25 0.000 1.000 0.125 0.125 0.250 #> mhs1 0.125 0.125 0.25 0.125 0.125 1.000 0.250 0.125 #> mhs2 0.125 0.125 0.25 0.125 0.125 0.250 1.000 0.125 #> mau1 0.125 0.125 0.25 0.250 0.250 0.125 0.125 1.000 #> attr(,\"fam_vec\") #> [1] \"g\"    \"o\"    \"m\"    \"mgm\"  \"mgf\"  \"mhs1\" \"mhs2\" \"mau1\" #> attr(,\"n_fam\") #>  #>   g   m mau mgf mgm mhs   o  #>   1   1   1   1   1   2   1  #> attr(,\"add_ind\") #> [1] TRUE #> attr(,\"h2\") #> [1] 0.5 construct_covmat_single(fam_vec = NULL, n_fam = stats::setNames(c(1,1,1,2,2), c(\"m\",\"mgm\",\"mgf\",\"s\",\"mhs\")), add_ind = FALSE, h2 = 0.3) #>         m   mgm   mgf    s1    s2  mhs1  mhs2 #> m    1.00 0.150 0.150 0.150 0.150 0.150 0.150 #> mgm  0.15 1.000 0.000 0.075 0.075 0.075 0.075 #> mgf  0.15 0.000 1.000 0.075 0.075 0.075 0.075 #> s1   0.15 0.075 0.075 1.000 0.150 0.075 0.075 #> s2   0.15 0.075 0.075 0.150 1.000 0.075 0.075 #> mhs1 0.15 0.075 0.075 0.075 0.075 1.000 0.150 #> mhs2 0.15 0.075 0.075 0.075 0.075 0.150 1.000 #> attr(,\"fam_vec\") #> [1] \"m\"    \"mgm\"  \"mgf\"  \"s1\"   \"s2\"   \"mhs1\" \"mhs2\" #> attr(,\"n_fam\") #>   m mgm mgf   s mhs  #>   1   1   1   2   2  #> attr(,\"add_ind\") #> [1] FALSE #> attr(,\"h2\") #> [1] 0.3"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_cir.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert age to cumulative incidence rate — convert_age_to_cir","title":"Convert age to cumulative incidence rate — convert_age_to_cir","text":"convert_age_to_cir computes cumulative incidence rate person's age.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_cir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert age to cumulative incidence rate — convert_age_to_cir","text":"","code":"convert_age_to_cir(age, pop_prev = 0.1, mid_point = 60, slope = 1/8)"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_cir.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert age to cumulative incidence rate — convert_age_to_cir","text":"age non-negative number representing individual's age. pop_prev positive number representing overall population prevalence. Must 1. Defaults 0.1. mid_point positive number representing mid point logistic function. Defaults 60. slope number holding rate increase. Defaults 1/8.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_cir.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert age to cumulative incidence rate — convert_age_to_cir","text":"age mid_point positive numbers, pop_prev positive number 0 1 slope valid number, convert_age_to_cir returns number, equal cumulative incidence rate.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_cir.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert age to cumulative incidence rate — convert_age_to_cir","text":"Given person's age, convert_age_to_cir can used compute cumulative incidence rate (cir), given formula $$pop\\_ prev / (1 + exp((mid\\_ point - age) * slope))$$","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_cir.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert age to cumulative incidence rate — convert_age_to_cir","text":"","code":"curve(sapply(age, convert_age_to_cir), from = 10, to = 110, xname = \"age\")"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_thresh.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert age to threshold — convert_age_to_thresh","title":"Convert age to threshold — convert_age_to_thresh","text":"convert_age_to_thresh computes threshold person's age using either logistic function truncated normal distribution","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_thresh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert age to threshold — convert_age_to_thresh","text":"","code":"convert_age_to_thresh(   age,   dist = \"logistic\",   pop_prev = 0.1,   mid_point = 60,   slope = 1/8,   min_age = 10,   max_age = 90,   lower = stats::qnorm(0.05, lower.tail = FALSE),   upper = Inf )"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_thresh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert age to threshold — convert_age_to_thresh","text":"age non-negative number representing individual's age. dist string indicating distribution use. dist = \"logistic\", logistic function used compute age onset. dist = \"normal\", truncated normal distribution used instead. Defaults \"logistic\". pop_prev necessary dist = \"logistic\". positive number representing overall population prevalence. Must 1. Defaults 0.1. mid_point necessary dist = \"logistic\". positive number representing mid point logistic function. Defaults 60. slope necessary dist = \"logistic\". number holding rate increase. Defaults 1/8. min_age necessary dist = \"normal\". positive number representing individual's earliest age. Defaults 10. max_age necessary dist = \"normal\". positive number representing individual's latest age. Must greater min_aoo. Defaults 90. lower necessary dist = \"normal\". number representing lower cutoff point truncated normal distribution. Defaults 1.645 (stats::qnorm(0.05, lower.tail = FALSE)). upper necessary dist = \"normal\". number representing upper cutoff point truncated normal distribution. Must greater equal lower. Defaults Inf.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_thresh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert age to threshold — convert_age_to_thresh","text":"age positive number necessary arguments valid, convert_age_to_thresh returns number, equal threshold.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_thresh.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert age to threshold — convert_age_to_thresh","text":"Given person's age, convert_age_to_thresh can used first compute cumulative incidence rate (cir), used compute threshold using either logistic function truncated normal distribution. logistic function, formula used compute threshold individual's age given $$qnorm(pop\\_ prev / (1 + exp((mid\\_ point - age) * slope)), lower.tail = F)$$, given $$qnorm((1 - (age-min\\_ age)/max\\_ age) * (pnorm(upper) - pnorm(lower)) + pnorm(lower))$$ truncated normal distribution.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_age_to_thresh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert age to threshold — convert_age_to_thresh","text":"","code":"curve(sapply(age, convert_age_to_thresh), from = 10, to = 110, xname = \"age\")"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_cir_to_age.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert cumulative incidence rate to age — convert_cir_to_age","title":"Convert cumulative incidence rate to age — convert_cir_to_age","text":"convert_cir_to_age computes age person's cumulative incidence rate.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_cir_to_age.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert cumulative incidence rate to age — convert_cir_to_age","text":"","code":"convert_cir_to_age(cir, pop_prev = 0.1, mid_point = 60, slope = 1/8)"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_cir_to_age.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert cumulative incidence rate to age — convert_cir_to_age","text":"cir positive number representing individual's cumulative incidence rate. pop_prev positive number representing overall population prevalence. Must 1 must larger cir. Defaults 0.1. mid_point positive number representing mid point logistic function. Defaults 60. slope number holding rate increase. Defaults 1/8.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_cir_to_age.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert cumulative incidence rate to age — convert_cir_to_age","text":"cir mid_point positive numbers, pop_prev positive number 0 1 slope valid number, convert_cir_to_age returns number, equal current age.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_cir_to_age.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert cumulative incidence rate to age — convert_cir_to_age","text":"Given person's cumulative incidence rate (cir), convert_cir_to_age can used compute corresponding age, given $$mid\\_ point - \\log(pop\\_ prev/cir - 1) * 1/slope$$","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_cir_to_age.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert cumulative incidence rate to age — convert_cir_to_age","text":"","code":"curve(sapply(cir, convert_cir_to_age), from = 0.001, to = 0.099, xname = \"cir\")"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_format.html","id":null,"dir":"Reference","previous_headings":"","what":"Attempts to convert the list entry input format to a long format — convert_format","title":"Attempts to convert the list entry input format to a long format — convert_format","text":"Attempts convert list entry input format long format","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attempts to convert the list entry input format to a long format — convert_format","text":"","code":"convert_format(family, threshs, personal_id_col = \"pid\", role_col = NULL)"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attempts to convert the list entry input format to a long format — convert_format","text":"family tibble two entries, family id personal id. personal id end \"_role\", role column present. threshs thresholds, personal id (without role) well lower upper thresholds personal_id_col column name holds personal id role_col column name holds role","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attempts to convert the list entry input format to a long format — convert_format","text":"returns format similar prepare_thresholds, used estimate_liability","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Attempts to convert the list entry input format to a long format — convert_format","text":"","code":"family <- data.frame( fid = c(1, 1, 1, 1), pid = c(1, 2, 3, 4), role = c(\"o\", \"m\", \"f\", \"pgf\") )  threshs <- data.frame(   pid = c(1, 2, 3, 4),   lower = c(-Inf, -Inf, 0.8, 0.7),   upper = c(0.8, 0.8, 0.8, 0.7) )  convert_format(family, threshs) #>   fid pid role lower upper #> 1   1   1    o  -Inf   0.8 #> 2   1   2    m  -Inf   0.8 #> 3   1   3    f   0.8   0.8 #> 4   1   4  pgf   0.7   0.7"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_liability_to_aoo.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert liability to age of onset — convert_liability_to_aoo","title":"Convert liability to age of onset — convert_liability_to_aoo","text":"convert_liability_to_aoo computes age onset individual's true underlying liability using either logistic function truncated normal distribution.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_liability_to_aoo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert liability to age of onset — convert_liability_to_aoo","text":"","code":"convert_liability_to_aoo(   liability,   dist = \"logistic\",   pop_prev = 0.1,   mid_point = 60,   slope = 1/8,   min_aoo = 10,   max_aoo = 90,   lower = stats::qnorm(0.05, lower.tail = FALSE),   upper = Inf )"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_liability_to_aoo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert liability to age of onset — convert_liability_to_aoo","text":"liability number representing individual's true underlying liability. dist string indicating distribution use. dist = \"logistic\", logistic function used compute age onset. dist = \"normal\", truncated normal distribution used instead. Defaults \"logistic\". pop_prev necessary dist = \"logistic\". positive number representing overall population prevalence. Must 1. Defaults 0.1. mid_point necessary dist = \"logistic\". positive number representing mid point logistic function. Defaults 60. slope necessary dist = \"logistic\". number holding rate increase. Defaults 1/8. min_aoo necessary dist = \"normal\". positive number representing individual's earliest age onset. Defaults 10. max_aoo necessary dist = \"normal\". positive number representing individual's latest age onset. Must greater min_aoo. Defaults 90. lower necessary dist = \"normal\". number representing lower cutoff point truncated normal distribution. Defaults 1.645 (stats::qnorm(0.05, lower.tail = FALSE)). upper necessary dist = \"normal\". number representing upper cutoff point truncated normal distribution. Must greater equal lower. Defaults Inf.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_liability_to_aoo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert liability to age of onset — convert_liability_to_aoo","text":"liability number necessary arguments valid, convert_liability_to_aoo returns positive number, equal age onset.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_liability_to_aoo.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert liability to age of onset — convert_liability_to_aoo","text":"Given person's cumulative incidence rate (cir), convert_liability_to_aoo can used compute corresponding age. logistic function, age given $$mid\\_ point - log(pop\\_ prev/cir - 1) * 1/slope$$, given $$(1 - truncated\\_ normal\\_ cdf(liability = liability, lower = lower , upper = upper)) * max\\_ aoo + min\\_ aoo$$ truncated normal distribution.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_liability_to_aoo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert liability to age of onset — convert_liability_to_aoo","text":"","code":"curve(sapply(liability, convert_liability_to_aoo), from = 1.3, to = 3.5, xname = \"liability\")  curve(sapply(liability, convert_liability_to_aoo, dist = \"normal\"),  from = qnorm(0.05, lower.tail = FALSE), to = 3.5, xname = \"liability\")"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_observed_to_liability_scale.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert the heritability on the observed scale to that on the liability scale — convert_observed_to_liability_scale","title":"Convert the heritability on the observed scale to that on the liability scale — convert_observed_to_liability_scale","text":"convert_observed_to_liability_scale transforms heritability observed scale heritability liability scale.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_observed_to_liability_scale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert the heritability on the observed scale to that on the liability scale — convert_observed_to_liability_scale","text":"","code":"convert_observed_to_liability_scale(   obs_h2 = 0.5,   pop_prev = 0.05,   prop_cases = 0.5 )"},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_observed_to_liability_scale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert the heritability on the observed scale to that on the liability scale — convert_observed_to_liability_scale","text":"obs_h2 number numeric vector representing liability-scale heritability(ies)observed scale. Must non-negative 1. Defaults 0.5 pop_prev number numeric vector representing population prevalence(s). entries must non-negative one. vector, must length obs_h2. Defaults 0.05. prop_cases Either NULL number numeric vector representing proportion cases sample. entries must non-negative one. vector, must length obs_h2. Defaults 0.5.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_observed_to_liability_scale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert the heritability on the observed scale to that on the liability scale — convert_observed_to_liability_scale","text":"obs_h2, pop_prev prop_cases non-negative numbers one, function returns heritability liability scale using Equation 23 Sang Hong Lee, Naomi R. Wray, Michael E. Goddard Peter M. Visscher, \"Estimating Missing Heritability Diseases Genome-wide Association Studies\", American Journal Human Genetics, Volume 88, Issue 3, 2011, pp. 294-305, doi:10.1016/j.ajhg.2011.02.002 . obs_h2, pop_prev prop_cases non-negative numeric vectors entries one, function returns vector length obs_h2. entry holds heritability liability scale obtained corresponding entry obs_h2 using Equation 23. obs_h2 pop_prev non-negative numbers one prop_cases NULL, function returns heritability liability scale using Equation 17 Sang Hong Lee, Naomi R. Wray, Michael E. Goddard Peter M. Visscher, \"Estimating Missing Heritability Diseases Genome-wide Association Studies\", American Journal Human Genetics, Volume 88, Issue 3, 2011, pp. 294-305, doi:10.1016/j.ajhg.2011.02.002 . obs_h2 pop_prev non-negative numeric vectors entries one, prop_cases NULL, convert_observed_to_liability_scale returns vector length obq_h2. entry holds liability-scale heritability obtained corresponding entry obs_h2 using Equation 17.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_observed_to_liability_scale.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert the heritability on the observed scale to that on the liability scale — convert_observed_to_liability_scale","text":"function can used transform heritability observed scale liability scale. convert_observed_to_liability_scale uses either Equation 17 (prop_cases = NULL) Equation 23 Sang Hong Lee, Naomi R. Wray, Michael E. Goddard Peter M. Visscher, \"Estimating Missing Heritability Diseases Genome-wide Association Studies\", American Journal Human Genetics, Volume 88, Issue 3, 2011, pp. 294-305, doi:10.1016/j.ajhg.2011.02.002  transform heritability observed scale heritability liability scale.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_observed_to_liability_scale.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Convert the heritability on the observed scale to that on the liability scale — convert_observed_to_liability_scale","text":"Sang Hong Lee, Naomi R. Wray, Michael E. Goddard, Peter M. Visscher (2011, March). Estimating Missing Heritability Diseases Genome-wide Association Studies. American Journal Human Genetics (Vol. 88, Issue 3, pp. 294-305). doi:10.1016/j.ajhg.2011.02.002","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/convert_observed_to_liability_scale.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert the heritability on the observed scale to that on the liability scale — convert_observed_to_liability_scale","text":"","code":"convert_observed_to_liability_scale() #> [1] 0.4242283 convert_observed_to_liability_scale(prop_cases=NULL) #> [1] 2.232781 convert_observed_to_liability_scale(obs_h2 = 0.8, pop_prev = 1/44,                                     prop_cases = NULL) #> [1] 6.105859 convert_observed_to_liability_scale(obs_h2 = c(0.5,0.8),                                     pop_prev = c(0.05, 1/44),                                     prop_cases = NULL) #> [1] 2.232781 6.105859"},{"path":"https://emilmip.github.io/LTFGRS/reference/correct_positive_definite.html","id":null,"dir":"Reference","previous_headings":"","what":"Positive definite matrices — correct_positive_definite","title":"Positive definite matrices — correct_positive_definite","text":"correct_positive_definite verifies given covariance matrix indeed positive definite checking eigenvalues positive. given covariance matrix positive definite, correct_positive_definite tries modify underlying correlation matrices genetic_corrmat full_corrmat order obtain positive definite covariance matrix.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/correct_positive_definite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Positive definite matrices — correct_positive_definite","text":"","code":"correct_positive_definite(   covmat,   correction_val = 0.99,   correction_limit = 100 )"},{"path":"https://emilmip.github.io/LTFGRS/reference/correct_positive_definite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Positive definite matrices — correct_positive_definite","text":"covmat symmetric numeric matrix. covariance matrix corrected, must number attributes, attr(covmat,\"fam_vec\"), attr(covmat,\"n_fam\"), attr(covmat,\"add_ind\"), attr(covmat,\"h2\"), attr(covmat,\"genetic_corrmat\"), attr(covmat,\"full_corrmat\") attr(covmat,\"phenotype_names\"). covariance matrix obtained construct_covmat, construct_covmat_single construct_covmat_multi attributes default. correction_val positive number representing amount genetic_corrmat full_corrmat changed, eigenvalues non-positive. , correction_val number multiplied off_diagonal entries genetic_corrmat full_corrmat. Defaults 0.99. correction_limit positive integer representing upper limit correction procedure. Defaults 100.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/correct_positive_definite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Positive definite matrices — correct_positive_definite","text":"covmat symmetric numeric matrix eigenvalues positive, correct_positive_definite simply returns covmat. eigenvalues positive correction_val positive number, correct_positive_definite tries convert covmat positive definite matrix. covmat attributes add_ind, h2, genetic_corrmat, full_corrmat phenotype_names, correct_positive_definite computes new covariance matrix using slightly modified correlation matrices genetic_corrmat full_corrmat. correction performed successfully, .e. new covariance matrix positive definite,new covariance matrix returned. Otherwise, correct_positive_definite returns original covariance matrix.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/correct_positive_definite.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Positive definite matrices — correct_positive_definite","text":"function can used verify given covariance matrix positive definite. calculates eigenvalues order investigate whether positive. property necessary covariance matrix used Gaussian covariance matrix. especially useful check whether covariance matrix obtained construct_covmat_multi positive definite. given covariance matrix positive definite, correct_positive_definite tries modify underlying correlation matrices (called genetic_corrmat full_corrmat construct_covmat construct_covmat_multi) multiplying -diagonal entries correlation matrices given number.","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/reference/correct_positive_definite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Positive definite matrices — correct_positive_definite","text":"","code":"ntrait <- 2 genetic_corrmat <- matrix(0.6, ncol = ntrait, nrow = ntrait) diag(genetic_corrmat) <- 1 full_corrmat <- matrix(-0.25, ncol = ntrait, nrow = ntrait) diag(full_corrmat) <- 1 h2_vec <- rep(0.6, ntrait) cov <- construct_covmat(fam_vec = c(\"m\", \"f\"),   genetic_corrmat = genetic_corrmat,   h2 = h2_vec,   full_corrmat = full_corrmat) cov #>              g_phenotype1 o_phenotype1 m_phenotype1 f_phenotype1 g_phenotype2 #> g_phenotype1         0.60         0.60         0.30         0.30         0.36 #> o_phenotype1         0.60         1.00         0.30         0.30         0.36 #> m_phenotype1         0.30         0.30         1.00         0.00         0.18 #> f_phenotype1         0.30         0.30         0.00         1.00         0.18 #> g_phenotype2         0.36         0.36         0.18         0.18         0.60 #> o_phenotype2         0.36        -0.25         0.18         0.18         0.60 #> m_phenotype2         0.18         0.18        -0.25         0.00         0.30 #> f_phenotype2         0.18         0.18         0.00        -0.25         0.30 #>              o_phenotype2 m_phenotype2 f_phenotype2 #> g_phenotype1         0.36         0.18         0.18 #> o_phenotype1        -0.25         0.18         0.18 #> m_phenotype1         0.18        -0.25         0.00 #> f_phenotype1         0.18         0.00        -0.25 #> g_phenotype2         0.60         0.30         0.30 #> o_phenotype2         1.00         0.30         0.30 #> m_phenotype2         0.30         1.00         0.00 #> f_phenotype2         0.30         0.00         1.00 #> attr(,\"fam_vec\") #> [1] \"g\" \"o\" \"m\" \"f\" #> attr(,\"n_fam\") #>  #> f g m o  #> 1 1 1 1  #> attr(,\"add_ind\") #> [1] TRUE #> attr(,\"h2\") #> [1] 0.6 0.6 #> attr(,\"genetic_corrmat\") #>      [,1] [,2] #> [1,]  1.0  0.6 #> [2,]  0.6  1.0 #> attr(,\"full_corrmat\") #>       [,1]  [,2] #> [1,]  1.00 -0.25 #> [2,] -0.25  1.00 #> attr(,\"phenotype_names\") #> [1] \"phenotype1\" \"phenotype2\" correct_positive_definite(cov) #> The specified covariance matrix is not positive definite.  #> Trying to correct the covariance matrix... #> The correction was performed successfully! All off-diagonal entries are corrected by0.656. #>              g_phenotype1 o_phenotype1 m_phenotype1 f_phenotype1 g_phenotype2 #> g_phenotype1    0.6000000    0.6000000    0.3000000    0.3000000    0.2360373 #> o_phenotype1    0.6000000    1.0000000    0.3000000    0.3000000    0.2360373 #> m_phenotype1    0.3000000    0.3000000    1.0000000    0.0000000    0.1180187 #> f_phenotype1    0.3000000    0.3000000    0.0000000    1.0000000    0.1180187 #> g_phenotype2    0.2360373    0.2360373    0.1180187    0.1180187    0.6000000 #> o_phenotype2    0.2360373   -0.1639148    0.1180187    0.1180187    0.6000000 #> m_phenotype2    0.1180187    0.1180187   -0.1639148    0.0000000    0.3000000 #> f_phenotype2    0.1180187    0.1180187    0.0000000   -0.1639148    0.3000000 #>              o_phenotype2 m_phenotype2 f_phenotype2 #> g_phenotype1    0.2360373    0.1180187    0.1180187 #> o_phenotype1   -0.1639148    0.1180187    0.1180187 #> m_phenotype1    0.1180187   -0.1639148    0.0000000 #> f_phenotype1    0.1180187    0.0000000   -0.1639148 #> g_phenotype2    0.6000000    0.3000000    0.3000000 #> o_phenotype2    1.0000000    0.3000000    0.3000000 #> m_phenotype2    0.3000000    1.0000000    0.0000000 #> f_phenotype2    0.3000000    0.0000000    1.0000000 #> attr(,\"fam_vec\") #> [1] \"g\" \"o\" \"m\" \"f\" #> attr(,\"n_fam\") #>  #> f g m o  #> 1 1 1 1  #> attr(,\"add_ind\") #> [1] TRUE #> attr(,\"h2\") #> [1] 0.6 0.6 #> attr(,\"genetic_corrmat\") #>           [,1]      [,2] #> [1,] 1.0000000 0.3933955 #> [2,] 0.3933955 1.0000000 #> attr(,\"full_corrmat\") #>            [,1]       [,2] #> [1,]  1.0000000 -0.1639148 #> [2,] -0.1639148  1.0000000 #> attr(,\"phenotype_names\") #> [1] \"phenotype1\" \"phenotype2\""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_gen_liability_ltfh.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate genetic liability similar to LT-FH — estimate_gen_liability_ltfh","title":"Estimate genetic liability similar to LT-FH — estimate_gen_liability_ltfh","text":"Estimate genetic liability similar LT-FH","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_gen_liability_ltfh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate genetic liability similar to LT-FH — estimate_gen_liability_ltfh","text":"","code":"estimate_gen_liability_ltfh(   h2,   phen,   child_threshold,   parent_threshold,   status_col_offspring = \"CHILD_STATUS\",   status_col_father = \"P1_STATUS\",   status_col_mother = \"P2_STATUS\",   status_col_siblings = \"SIB_STATUS\",   number_of_siblings_col = \"NUM_SIBS\",   tol = 0.01 )"},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_gen_liability_ltfh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate genetic liability similar to LT-FH — estimate_gen_liability_ltfh","text":"h2 Liability scale heritability trait analysed. phen tibble data.frame status genotyped individual, parents siblings. child_threshold single numeric value used threshold offspring siblings. parent_threshold single numeric value used threshold parents status_col_offspring Column name status offspring status_col_father Column name status father status_col_mother Column name status mother status_col_siblings Column name status siblings number_of_siblings_col Column name number siblings given individual tol Convergence criteria Gibbs sampler. Default 0.01, meaning standard error mean 0.01","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_gen_liability_ltfh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate genetic liability similar to LT-FH — estimate_gen_liability_ltfh","text":"Returns estimated genetic liabilities.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_gen_liability_ltfh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate genetic liability similar to LT-FH — estimate_gen_liability_ltfh","text":"","code":"phen <- data.frame( CHILD_STATUS = c(0,0), P1_STATUS = c(1,1), P2_STATUS = c(0,1), SIB_STATUS = c(1,0), NUM_SIBS = c(2,0))  h2 <- 0.5 child_threshold <- 0.7 parent_threshold <- 0.8  estimate_gen_liability_ltfh(h2, phen, child_threshold, parent_threshold) #>   CHILD_STATUS P1_STATUS P2_STATUS SIB_STATUS NUM_SIBS post_gen_liab #> 1            0         1         0          1        2     0.1523602 #> 2            0         1         1          0        0     0.3486383 #>   post_gen_liab_se #> 1      0.003201985 #> 2      0.003164997"},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimating the genetic or full liability for a variable number of phenotypes — estimate_liability","title":"Estimating the genetic or full liability for a variable number of phenotypes — estimate_liability","text":"estimate_liability estimates genetic component full liability /full liability number individuals based family history one phenotypes.  wrapper around estimate_liability_single estimate_liability_multi.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimating the genetic or full liability for a variable number of phenotypes — estimate_liability","text":"","code":"estimate_liability(   .tbl = NULL,   family_graphs = NULL,   h2 = 0.5,   pid = \"pid\",   fid = \"fid\",   role = \"role\",   family_graphs_col = \"fam_graph\",   out = c(1),   tol = 0.01,   method = \"PA\",   useMixture = FALSE,   genetic_corrmat = NULL,   full_corrmat = NULL,   phen_names = NULL )"},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimating the genetic or full liability for a variable number of phenotypes — estimate_liability","text":".tbl matrix, list data frame can converted tibble. Must least five columns hold family identifier, personal identifier, role lower upper thresholds phenotypes interest. Note role must one following abbreviations - g (Genetic component full liability) - o (Full liability) - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side). Defaults NULL. family_graphs tibble columns pid family_graph_col. See prepare_graph construction graphs. family graphs Defaults NULL. h2 Either number representing heritability liability scale single phenotype, numeric vector representing liability-scale heritabilities phenotypes. entries h2 must non-negative 1. pid string holding name column family threshs hold personal identifier(s). Defaults \"PID\". fid string holding name column family holds family identifier. Defaults \"fid\". role string holding name column .tbl holds role.role must chosen following list abbreviations - g (Genetic component full liability) - o (Full liability) - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side). Defaults \"role\". family_graphs_col Name column family graphs family_graphs. Defaults \"fam_graph\". character numeric vector indicating whether genetic component full liability, full liability returned. = c(1) = c(\"genetic\"), genetic liability estimated returned. = c(2) = c(\"full\"), full liability estimated returned. = c(1,2) = c(\"genetic\", \"full\"), components estimated returned. Defaults c(1). tol number used convergence criterion Gibbs sampler. Equals standard error mean. , tolerance 0.2 means standard error mean 0.2. Defaults 0.01. method Estimation method used estimate (genetic) liability. Defaults \"PA\". Current implementation PA supports estimates genetic liability. full genetic full liability estimates use \"Gibbs\". useMixture Logical indicating whether mixture model used calculate genetic liability. Requires K_i K_pop columns well lower upper. Defaults FALSE. genetic_corrmat Either NULL (h2 number) numeric matrix (h2 vector length > 1) holding genetic correlations desired phenotypes. diagonal entries must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. Defaults NULL. full_corrmat Either NULL (h2 number) numeric matrix (h2 vector length > 1) holding full correlations desired phenotypes. diagonal entries must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. Defaults NULL. phen_names Either NULL character vector holding phenotype names. names used create row column names covariance matrix. specified, names default phenotype1, phenotype2, etc. Defaults NULL.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimating the genetic or full liability for a variable number of phenotypes — estimate_liability","text":"family threshs two matrices, lists data frames can converted tibbles, family two columns named like strings represented pid fid, threshs column named like string given pid well column named \"lower\" column named \"upper\" liability-scale heritability h2 number (length(h2)=1), , tol always_add required form, function returns tibble either four six columns (depending length ). first two columns correspond columns fid pid ' present family. equal c(1) c(\"genetic\"), third fourth column hold estimated genetic liability well corresponding standard error, respectively. equals c(2) c(\"full\"), third fourth column hold estimated full liability well corresponding standard error, respectively. equal c(1,2) c(\"genetic\",\"full\"), third fourth column hold estimated genetic liability well corresponding standard error, respectively, fifth sixth column hold estimated full liability well corresponding standard error, respectively. h2 numeric vector length greater 1 genetic_corrmat, full_corrmat, tol required form, function returns tibble least six columns (depending length ). first two columns correspond columns fid pid present tibble family. equal c(1) c(\"genetic\"), third fourth columns hold estimated genetic liability well corresponding standard error first phenotype, respectively. equals c(2) c(\"full\"), third fourth columns hold estimated full liability well corresponding standard error first phenotype, respectively. equal c(1,2) c(\"genetic\",\"full\"), third fourth columns hold estimated genetic liability well corresponding standard error first phenotype, respectively, fifth sixth columns hold estimated full liability well corresponding standard error first phenotype, respectively. remaining columns hold estimated genetic liabilities /estimated full liabilities well corresponding standard errors remaining phenotypes.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimating the genetic or full liability for a variable number of phenotypes — estimate_liability","text":"function can used estimate either genetic component full liability, full liability variable number traits.","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimating the genetic or full liability for a variable number of phenotypes — estimate_liability","text":"","code":"genetic_corrmat <- matrix(0.4, 3, 3) diag(genetic_corrmat) <- 1 full_corrmat <- matrix(0.6, 3, 3) diag(full_corrmat) <- 1 # sims <- simulate_under_LTM(fam_vec = c(\"m\",\"f\"), n_fam = NULL, add_ind = TRUE, genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat, h2 = rep(.5,3), n_sim = 1, pop_prev = rep(.1,3)) estimate_liability(.tbl = sims$thresholds, h2 = rep(.5,3), genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat, pid = \"indiv_ID\", fid = \"fid\", role = \"role\", out = c(1), phen_names = paste0(\"phenotype\", 1:3), tol = 0.01) #> The number of workers is 1 #> # A tibble: 1 × 8 #>   fid   indiv_ID genetic_phenotype1_est genetic_phenotype1_se #>   <chr> <chr>                     <dbl>                 <dbl> #> 1 fid_1 fid_1                   -0.0158               0.00769 #> # ℹ 4 more variables: genetic_phenotype2_est <dbl>, #> #   genetic_phenotype2_se <dbl>, genetic_phenotype3_est <dbl>, #> #   genetic_phenotype3_se <dbl>"},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimating the genetic or full liability for multiple phenotypes — estimate_liability_multi","title":"Estimating the genetic or full liability for multiple phenotypes — estimate_liability_multi","text":"estimate_liability_multi estimates genetic component full liability /full liability number individuals based family history variable number phenotypes.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimating the genetic or full liability for multiple phenotypes — estimate_liability_multi","text":"","code":"estimate_liability_multi(   .tbl = NULL,   family_graphs = NULL,   h2_vec,   genetic_corrmat,   full_corrmat,   phen_names = NULL,   pid = \"pid\",   fid = \"fid\",   role = \"role\",   family_graphs_col = \"fam_graph\",   out = c(1),   tol = 0.01 )"},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimating the genetic or full liability for multiple phenotypes — estimate_liability_multi","text":".tbl matrix, list data frame can converted tibble. Must least seven columns hold family identifier, personal identifier, role lower upper thresholds phenotypes interest. Note role must one following abbreviations - g (Genetic component full liability) - o (Full liability) - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side). Defaults NULL. family_graphs tibble columns pid family_graph_col. See prepare_graph construction graphs. family graphs Defaults NULL. h2_vec numeric vector representing liability-scale heritabilities phenotypes. entries h2_vec must non-negative 1. genetic_corrmat numeric matrix holding genetic correlations desired phenotypes. diagonal entries must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. full_corrmat numeric matrix holding full correlations desired phenotypes. diagonal entries must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. phen_names character vector holding phenotype names. names used create row column names covariance matrix. specified, names default phenotype1, phenotype2, etc. Defaults NULL. pid string holding name column family threshs hold personal identifier(s). Defaults \"PID\". fid string holding name column family holds family identifier. Defaults \"fid\". role string holding name column .tbl holds role.role must chosen following list abbreviations - g (Genetic component full liability) - o (Full liability) - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side). Defaults \"role\". family_graphs_col Name column family graphs family_graphs. Defaults \"fam_graph\". character numeric vector indicating whether genetic component full liability, full liability returned. = c(1) = c(\"genetic\"), genetic liability estimated returned. = c(2) = c(\"full\"), full liability estimated returned. = c(1,2) = c(\"genetic\", \"full\"), components estimated returned. Defaults c(1). tol number used convergence criterion Gibbs sampler. Equals standard error mean. , tolerance 0.2 means standard error mean 0.2. Defaults 0.01.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_multi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimating the genetic or full liability for multiple phenotypes — estimate_liability_multi","text":"family threshs two matrices, lists data frames can converted tibbles, family two columns named like strings represented pid fid, threshs column named like string given pid well column named \"lower\" column named \"upper\" liability-scale heritabilities h2_vec, genetic_corrmat, full_corrmat, tol required form, function returns tibble least six columns (depending length ). first two columns correspond columns fid pid present tibble family. equal c(1) c(\"genetic\"), third fourth columns hold estimated genetic liability well corresponding standard error first phenotype, respectively. equals c(2) c(\"full\"), third fourth columns hold estimated full liability well corresponding standard error first phenotype, respectively. equal c(1,2) c(\"genetic\",\"full\"), third fourth columns hold estimated genetic liability well corresponding standard error first phenotype, respectively, fifth sixth columns hold estimated full liability well corresponding standard error first phenotype, respectively. remaining columns hold estimated genetic liabilities /estimated full liabilities well corresponding standard errors remaining phenotypes.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_multi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimating the genetic or full liability for multiple phenotypes — estimate_liability_multi","text":"function can used estimate either genetic component full liability, full liability variable number traits.","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_multi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimating the genetic or full liability for multiple phenotypes — estimate_liability_multi","text":"","code":"genetic_corrmat <- matrix(0.4, 3, 3) diag(genetic_corrmat) <- 1 full_corrmat <- matrix(0.6, 3, 3) diag(full_corrmat) <- 1 # sims <- simulate_under_LTM(fam_vec = c(\"m\",\"f\"), n_fam = NULL, add_ind = TRUE, genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat, h2 = rep(.5,3), n_sim = 1, pop_prev = rep(.1,3)) estimate_liability_multi(.tbl = sims$thresholds, h2_vec = rep(.5,3), genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat, pid = \"indiv_ID\", fid = \"fid\", role = \"role\", out = c(1), phen_names = paste0(\"phenotype\", 1:3), tol = 0.01) #> The number of workers is 1 #> # A tibble: 1 × 8 #>   fid   indiv_ID genetic_phenotype1_est genetic_phenotype1_se #>   <chr> <chr>                     <dbl>                 <dbl> #> 1 fid_1 fid_1                    0.0198               0.00696 #> # ℹ 4 more variables: genetic_phenotype2_est <dbl>, #> #   genetic_phenotype2_se <dbl>, genetic_phenotype3_est <dbl>, #> #   genetic_phenotype3_se <dbl>"},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimating the genetic or full liability — estimate_liability_single","title":"Estimating the genetic or full liability — estimate_liability_single","text":"estimate_liability_single estimates genetic component full liability /full liability number individuals based family history.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimating the genetic or full liability — estimate_liability_single","text":"","code":"estimate_liability_single(   .tbl = NULL,   family_graphs = NULL,   h2 = 0.5,   pid = \"pid\",   fid = \"fid\",   family_graphs_col = \"fam_graph\",   role = NULL,   out = c(1),   tol = 0.01,   useMixture = FALSE,   method = \"PA\" )"},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimating the genetic or full liability — estimate_liability_single","text":".tbl matrix, list data frame can converted tibble. Must least five columns hold family identifier, personal identifier, role lower upper thresholds. Note role must one following abbreviations - g (Genetic component full liability) - o (Full liability) - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side). Defaults NULL. family_graphs tibble columns pid family_graph_col. See prepare_graph construction graphs. family graphs Defaults NULL. h2 number representing heritability liability scale single phenotype. Must non-negative. Note liability threshold model, heritability must also 1. Defaults 0.5. pid string holding name column .tbl (family threshs) hold personal identifier(s). Defaults \"PID\". fid string holding name column .tbl family holds family identifier. Defaults \"fid\". family_graphs_col Name column family graphs family_graphs. Defaults \"fam_graph\". role string holding name column .tbl holds role. role must chosen following list abbreviations - g (Genetic component full liability) - o (Full liability) - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side). Defaults \"role\". character numeric vector indicating whether genetic component full liability, full liability returned. = c(1) = c(\"genetic\"), genetic liability estimated returned. = c(2) = c(\"full\"), full liability estimated returned. = c(1,2) = c(\"genetic\", \"full\"), components estimated returned. Defaults c(1). tol number used convergence criterion Gibbs sampler. Equals standard error mean. , tolerance 0.2 means standard error mean 0.2. Defaults 0.01. useMixture Logical indicating whether mixture model used calculate genetic liability. Requires K_i K_pop columns well lower upper. Defaults FALSE. method Estimation method used estimate (genetic) liability. Defaults \"PA\". Current implementation PA supports estimates genetic liability. full genetic full liability estimates use \"Gibbs\".","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimating the genetic or full liability — estimate_liability_single","text":"family threshs two matrices, lists data frames can converted tibbles, family two columns named like strings represented pid fid, threshs column named like string given pid well column named \"lower\" column named \"upper\" liability-scale heritability h2, , tol always_add required form, function returns tibble either four six columns (depending length ). first two columns correspond columns fid pid ' present family. equal c(1) c(\"genetic\"), third fourth column hold estimated genetic liability well corresponding standard error, respectively. equals c(2) c(\"full\"), third fourth column hold estimated full liability well corresponding standard error, respectively. equal c(1,2) c(\"genetic\",\"full\"), third fourth column hold estimated genetic liability well corresponding standard error, respectively, fifth sixth column hold estimated full liability well corresponding standard error, respectively.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_single.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimating the genetic or full liability — estimate_liability_single","text":"function can used estimate either genetic component full liability, full liability . possible input either","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/reference/estimate_liability_single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimating the genetic or full liability — estimate_liability_single","text":"","code":"sims <- simulate_under_LTM(fam_vec = c(\"m\",\"f\",\"s1\"), n_fam = NULL, add_ind = TRUE, h2 = 0.5, n_sim=10, pop_prev = .05) # estimate_liability_single(.tbl = sims$thresholds, h2 = 0.5, pid = \"indiv_ID\", fid = \"fid\", role = \"role\", out = c(1), tol = 0.01) #> The number of workers is 1 #> # A tibble: 10 × 4 #>    fid    indiv_ID     est   var #>    <chr>  <chr>      <dbl> <dbl> #>  1 fid_1  fid_1    -0.0197 0.487 #>  2 fid_2  fid_2    -0.0173 0.489 #>  3 fid_3  fid_3    -0.0300 0.481 #>  4 fid_4  fid_4    -0.0337 0.483 #>  5 fid_5  fid_5    -0.0191 0.489 #>  6 fid_6  fid_6    -0.0393 0.479 #>  7 fid_7  fid_7    -0.0372 0.479 #>  8 fid_8  fid_8    -0.0226 0.486 #>  9 fid_9  fid_9    -0.0136 0.492 #> 10 fid_10 fid_10   -0.0342 0.482 # sims <- simulate_under_LTM(fam_vec = c(), n_fam = NULL, add_ind = TRUE, h2 = 0.5, n_sim=10, pop_prev = .05) #> Warning: Neither fam_vec nor n_fam is specified... # estimate_liability_single(.tbl = sims$thresholds, h2 = 0.5, pid = \"indiv_ID\", fid = \"fid\", role = \"role\", out = c(\"genetic\"), tol = 0.01) #> The number of workers is 1 #> # A tibble: 10 × 4 #>    fid    indiv_ID       est   var #>    <chr>  <chr>        <dbl> <dbl> #>  1 fid_1  fid_1    -0.000687 0.499 #>  2 fid_2  fid_2    -0.00511  0.493 #>  3 fid_3  fid_3    -0.00239  0.496 #>  4 fid_4  fid_4    -0.00214  0.497 #>  5 fid_5  fid_5    -0.00239  0.496 #>  6 fid_6  fid_6    -0.00122  0.498 #>  7 fid_7  fid_7    -0.00413  0.494 #>  8 fid_8  fid_8    -0.00239  0.496 #>  9 fid_9  fid_9    -0.000687 0.499 #> 10 fid_10 fid_10   -0.000191 0.500"},{"path":"https://emilmip.github.io/LTFGRS/reference/extract_estimation_info_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Title Internal Function used to extact input needed from graph input for liability estimation — extract_estimation_info_graph","title":"Title Internal Function used to extact input needed from graph input for liability estimation — extract_estimation_info_graph","text":"Title Internal Function used extact input needed graph input liability estimation","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/extract_estimation_info_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title Internal Function used to extact input needed from graph input for liability estimation — extract_estimation_info_graph","text":"","code":"extract_estimation_info_graph(cur_fam_graph, cur_fid, h2, pid, add_ind = TRUE)"},{"path":"https://emilmip.github.io/LTFGRS/reference/extract_estimation_info_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title Internal Function used to extact input needed from graph input for liability estimation — extract_estimation_info_graph","text":"cur_fam_graph neightbourhood graph degree n around proband cur_fid proband ID h2 heritability value estimate_liability pid Name column personal ID add_ind Whether genetic liability added. Default TRUE.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/extract_estimation_info_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title Internal Function used to extact input needed from graph input for liability estimation — extract_estimation_info_graph","text":"list two elements: tbl (tibble relevant information) cov (covariance matrix) estimated graph_based_covariance_construction()","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/extract_estimation_info_tbl.html","id":null,"dir":"Reference","previous_headings":"","what":"Title Internal Function used to extact input needed for liability estimation — extract_estimation_info_tbl","title":"Title Internal Function used to extact input needed for liability estimation — extract_estimation_info_tbl","text":"Title Internal Function used extact input needed liability estimation","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/extract_estimation_info_tbl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title Internal Function used to extact input needed for liability estimation — extract_estimation_info_tbl","text":"","code":"extract_estimation_info_tbl(.tbl, cur_fid, h2, fid, pid, role, add_ind = TRUE)"},{"path":"https://emilmip.github.io/LTFGRS/reference/extract_estimation_info_tbl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title Internal Function used to extact input needed for liability estimation — extract_estimation_info_tbl","text":".tbl .tbl input estimate_liability cur_fid current family ID worked h2 heritability value estimate_liability fid name family ID column pid name personal ID column role name role column add_ind Whether genetic liability added. Default TRUE.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/extract_estimation_info_tbl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title Internal Function used to extact input needed for liability estimation — extract_estimation_info_tbl","text":"list two elements: tbl (tibble relevant information) cov (covariance matrix) estimated construct_covmat()","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/familywise_attach_attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrapper to attach attributes to family graphs — familywise_attach_attributes","title":"Wrapper to attach attributes to family graphs — familywise_attach_attributes","text":"function can attach attributes family graphs, lower upper thresholds, family member. allows personalised thresholds per-family specific attributes. function wraps around attach_attributes ease process attaching attributes family graphs standard format.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/familywise_attach_attributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrapper to attach attributes to family graphs — familywise_attach_attributes","text":"","code":"familywise_attach_attributes(   family_graphs,   fam_attr,   fam_graph_col = \"fam_graph\",   attached_fam_graph_col = \"masked_fam_graph\",   fid = \"fid\",   pid = \"pid\",   cols_to_attach = c(\"lower\", \"upper\"),   censor_proband_thrs = T )"},{"path":"https://emilmip.github.io/LTFGRS/reference/familywise_attach_attributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrapper to attach attributes to family graphs — familywise_attach_attributes","text":"family_graphs tibble family ids family graphs fam_attr tibble attributes family member fam_graph_col column name family graphs family_graphs. defailts \"fam_graph\" attached_fam_graph_col column name updated family graphs attached attributes. defaults \"masked_fam_graph\". fid column name family id. Typically contains name proband family graph centred . defaults \"fid\". pid personal identifier individual family. Allows multiple instances individual across families. Defaults \"pid\". cols_to_attach columns attach family graphs fam_attr, typically lower upper thresholds. Mixture input also requires K_i K_pop. censor_proband_thrs proband's upper lower thresholds made uninformative? Defaults TRUE. Used exclude proband's information prediction.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/familywise_attach_attributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrapper to attach attributes to family graphs — familywise_attach_attributes","text":"tibble family ids updated family graph attached attributes. lower upper thresholds specified, input ready estimate_liability().","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/familywise_attach_attributes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrapper to attach attributes to family graphs — familywise_attach_attributes","text":"","code":"# See Vignettes."},{"path":"https://emilmip.github.io/LTFGRS/reference/familywise_censoring.html","id":null,"dir":"Reference","previous_headings":"","what":"Censor Family Onsets for Multiple Families — familywise_censoring","title":"Censor Family Onsets for Multiple Families — familywise_censoring","text":"fucntion wrapper around censor_family_onsets. functions accepts tibble family graphs get_family_graphs. censors onset times individual family graph based proband's end follow-. Returns formatted output.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/familywise_censoring.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Censor Family Onsets for Multiple Families — familywise_censoring","text":"","code":"familywise_censoring(   family_graphs,   tbl,   start,   end,   event,   status_col = \"status\",   aod_col = \"aod\",   age_eof_col = \"age\",   fam_graph_col = \"fam_graph\",   fid = \"fid\",   pid = \"pid\",   merge_by = pid )"},{"path":"https://emilmip.github.io/LTFGRS/reference/familywise_censoring.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Censor Family Onsets for Multiple Families — familywise_censoring","text":"family_graphs Tibble fid family graphs columns. tbl Tibble information considered individual. start Column name start follow , typically date birth. end Column name personalised end follow . event Column name event. status_col Column name status (created). Defaults \"status\". aod_col Column name age diagnosis (created). Defaults \"aod\". age_eof_col Column name age end follow (created). Defaults \"age_eof\". fam_graph_col Column name family graphs 'family_graphs' object. Defaults \"fam_graph\". fid Family id, typically name proband family graph centred . Defaults \"fid\". pid Personal identifier individual. Allows multiple instances individual across families. Defaults \"pid\". merge_by Column names merge . different names used family graphs tbl, named vector can specified: setNames(c(\"id\"), c(\"pid\")). Note id column name tbl pid column name family_graphs. column names used reference personal identifier.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/familywise_censoring.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Censor Family Onsets for Multiple Families — familywise_censoring","text":"tibble family ids updated status, age diagnosis, age end follow-individual family based proband's end follow-.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/familywise_censoring.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Censor Family Onsets for Multiple Families — familywise_censoring","text":"","code":"# See Vignettes."},{"path":"https://emilmip.github.io/LTFGRS/reference/get_all_combs.html","id":null,"dir":"Reference","previous_headings":"","what":"construct all combinations of input vector — get_all_combs","title":"construct all combinations of input vector — get_all_combs","text":"pastes together combinations input vector","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_all_combs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"construct all combinations of input vector — get_all_combs","text":"","code":"get_all_combs(vec)"},{"path":"https://emilmip.github.io/LTFGRS/reference/get_all_combs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"construct all combinations of input vector — get_all_combs","text":"vec vector strings","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_all_combs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"construct all combinations of input vector — get_all_combs","text":"vector strings returned.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_all_combs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"construct all combinations of input vector — get_all_combs","text":"","code":"get_all_combs(letters[1:3]) #> [1] \"b_a\" \"c_a\" \"a_b\" \"c_b\" \"a_c\" \"b_c\""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_covmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct kinship matrix from graph — get_covmat","title":"Construct kinship matrix from graph — get_covmat","text":"construct kinship matrix graph representation family, centered index person (proband).","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_covmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct kinship matrix from graph — get_covmat","text":"","code":"get_covmat(fam_graph, h2, index_id = NA, add_ind = TRUE, fix_diag = TRUE)"},{"path":"https://emilmip.github.io/LTFGRS/reference/get_covmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct kinship matrix from graph — get_covmat","text":"fam_graph graph. h2 heritability. index_id proband id. used conjuction add_ind = TRUE. add_ind add genetic liability kinship matrix. Defaults true. fix_diag Whether set diagonal 1 entries except genetic liability.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_covmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct kinship matrix from graph — get_covmat","text":"kinship matrix.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_covmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct kinship matrix from graph — get_covmat","text":"","code":"fam <- data.frame( i = c(1, 2, 3, 4), f = c(3, 0, 4, 0), m = c(2, 0, 0, 0) )  thresholds <- data.frame(   i = c(1, 2, 3, 4),   lower = c(-Inf, -Inf, 0.8, 0.7),   upper = c(0.8, 0.8, 0.8, 0.7) )  graph <- prepare_graph(fam, icol = \"i\", fcol = \"f\", mcol = \"m\", node_attributes = thresholds)  get_covmat(graph, h2 = 0.5, index_id = \"1\") #>         1    2    3     4   1_g #> 1   1.000 0.25 0.25 0.125 0.500 #> 2   0.250 1.00 0.00 0.000 0.250 #> 3   0.250 0.00 1.00 0.250 0.250 #> 4   0.125 0.00 0.25 1.000 0.125 #> 1_g 0.500 0.25 0.25 0.125 0.500"},{"path":"https://emilmip.github.io/LTFGRS/reference/get_family_graphs.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatically identify family members of degree n — get_family_graphs","title":"Automatically identify family members of degree n — get_family_graphs","text":"function identifies individuals ndegree-steps away proband population graph.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_family_graphs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatically identify family members of degree n — get_family_graphs","text":"","code":"get_family_graphs(   pop_graph,   ndegree,   proband_vec,   fid = \"fid\",   fam_graph_col = \"fam_graph\",   mindist = 0,   mode = \"all\" )"},{"path":"https://emilmip.github.io/LTFGRS/reference/get_family_graphs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatically identify family members of degree n — get_family_graphs","text":"pop_graph Population graph prepare_graph() ndegree Number steps away proband include proband_vec Vector proband ids create family graphs . Must strings. fid Column name proband ids output. fam_graph_col Column name family graphs output. mindist Minimum distance proband exclude graph (experimental, untested), defaults 0, passed directly make_neighborhood_graph. mode Type distance measure graph (experimental, untested), defaults \"\", passed directly make_neighborhood_graph.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_family_graphs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatically identify family members of degree n — get_family_graphs","text":"Tibble two columns, family ids (fid) family graphs (fam_graph_col).","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_family_graphs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Automatically identify family members of degree n — get_family_graphs","text":"","code":"# See Vignettes."},{"path":"https://emilmip.github.io/LTFGRS/reference/get_onset_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate age of diagnosis, age at end of follow up, and status — get_onset_time","title":"Calculate age of diagnosis, age at end of follow up, and status — get_onset_time","text":"Calculate age diagnosis, age end follow , status","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_onset_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate age of diagnosis, age at end of follow up, and status — get_onset_time","text":"","code":"get_onset_time(   tbl,   start,   end,   event,   status_col = \"status\",   aod_col = \"aod\",   age_eof_col = \"age\" )"},{"path":"https://emilmip.github.io/LTFGRS/reference/get_onset_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate age of diagnosis, age at end of follow up, and status — get_onset_time","text":"tbl tibble start, end, event columns start start follow , typically birth date, must date column end end follow , must date column event event interest, typically date diagnosis, must date column status_col column name status column created. Defaults \"status\". aod_col column name age diagnosis column created. Defaults \"aod\". age_eof_col column name age end follow-column created. Defaults \"age_eof\".","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_onset_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate age of diagnosis, age at end of follow up, and status — get_onset_time","text":"tibble added status, age diagnosis, age end follow-","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_onset_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate age of diagnosis, age at end of follow up, and status — get_onset_time","text":"","code":"# See vignettes."},{"path":"https://emilmip.github.io/LTFGRS/reference/get_relatedness.html","id":null,"dir":"Reference","previous_headings":"","what":"Relatedness between a pair of family members — get_relatedness","title":"Relatedness between a pair of family members — get_relatedness","text":"get_relatedness returns relatedness times liability-scale heritability pair family members","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_relatedness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relatedness between a pair of family members — get_relatedness","text":"","code":"get_relatedness(s1, s2, h2 = 0.5, from_covmat = FALSE)"},{"path":"https://emilmip.github.io/LTFGRS/reference/get_relatedness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relatedness between a pair of family members — get_relatedness","text":"s1, s2 Strings representing two family members. strings must chosen following list strings: - g (Genetic component full liability) - o (Full liability) - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side). h2 number representing squared heritability liability scale. Must non-negative 1. Defaults 0.5 from_covmat logical variable. used internally. allows skip negative check.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_relatedness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relatedness between a pair of family members — get_relatedness","text":"s1 s2 strings chosen mentioned list strings h2 number satisfying \\(0 \\leq h2 \\leq 1\\), output number equals percentage shared DNA s1 s2 times squared heritability h2.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_relatedness.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relatedness between a pair of family members — get_relatedness","text":"function can used get percentage shared DNA times liability-scale heritability \\(h^2\\) two family members.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_relatedness.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Relatedness between a pair of family members — get_relatedness","text":"interested percentage shared DNA, set h2 = 1.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/get_relatedness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relatedness between a pair of family members — get_relatedness","text":"","code":"get_relatedness(\"g\",\"o\") #> [1] 0.5 get_relatedness(\"g\",\"f\", h2 = 1) #> [1] 0.5 get_relatedness(\"o\",\"s\", h2 = 0.3) #> [1] 0.15   # This will result in errors: try(get_relatedness(\"a\",\"b\")) #> Error in validate_relatives(s1) :  #>   s1 contains invalid abbreviations! Use strings from the following list:  #>  #>   - g (Genetic component of full liability) #>  #>   - o (Full liability) #>  #>   - m (Mother) #>  #>   - f (Father) #>  #>   - c[0-9]*.[0-9]* (Children) #>  #>   - mgm (Maternal grandmother) #>  #>   - mgf (Maternal grandfather) #>  #>   - pgm (Paternal grandmother) #>  #>   - pgf (Paternal grandfather) #>  #>   - s[0-9]* (Full siblings) #>  #>   - mhs[0-9]* (Half-siblings - maternal side) #>  #>   - phs[0-9]* (Half-siblings - paternal side) #>  #>   - mau[0-9]* (Aunts/Uncles - maternal side) #>  #>   - pau[0-9]* (Aunts/Uncles - paternal side). try(get_relatedness(m, mhs)) #> Error in eval(expr, envir) : object 'm' not found"},{"path":"https://emilmip.github.io/LTFGRS/reference/graph_based_covariance_construction.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructing covariance matrix from local family graph — graph_based_covariance_construction","title":"Constructing covariance matrix from local family graph — graph_based_covariance_construction","text":"Function constructs genetic covariance matrix given graph around proband extracts threshold information graph.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/graph_based_covariance_construction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructing covariance matrix from local family graph — graph_based_covariance_construction","text":"","code":"graph_based_covariance_construction(   pid,   cur_proband_id,   cur_family_graph,   h2,   add_ind = TRUE )"},{"path":"https://emilmip.github.io/LTFGRS/reference/graph_based_covariance_construction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructing covariance matrix from local family graph — graph_based_covariance_construction","text":"pid Name column personal ID cur_proband_id id proband cur_family_graph local graph current proband h2 liability scale heritability add_ind whether add genetic liability proband . Defaults true.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/graph_based_covariance_construction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructing covariance matrix from local family graph — graph_based_covariance_construction","text":"list two elements. first element temp_tbl, contains id current proband, family ID lower upper thresholds. second element, cov, covariance matrix local graph centered current proband.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/graph_based_covariance_construction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructing covariance matrix from local family graph — graph_based_covariance_construction","text":"","code":"fam <- data.frame(   id = c(\"pid\", \"mom\", \"dad\", \"pgf\"),   dadcol = c(\"dad\", 0, \"pgf\", 0),   momcol = c(\"mom\", 0, 0, 0))  thresholds <- data.frame(   id = c(\"pid\", \"mom\", \"dad\", \"pgf\"),   lower = c(-Inf, -Inf, 0.8, 0.7),   upper = c(0.8, 0.8, 0.8, 0.7))  graph <- prepare_graph(fam, icol = \"id\", fcol = \"dadcol\",  mcol = \"momcol\", node_attributes = thresholds)  graph_based_covariance_construction(pid = \"id\",                                     cur_proband_id = \"pid\",                                     cur_family_graph = graph,                                     h2 = 0.5) #> $temp_tbl #> # A tibble: 5 × 3 #>   id     lower upper #>   <chr>  <dbl> <dbl> #> 1 pid_g -Inf   Inf   #> 2 pid   -Inf     0.8 #> 3 mom   -Inf     0.8 #> 4 dad      0.8   0.8 #> 5 pgf      0.7   0.7 #>  #> $covmat #>       pid_g   pid  mom  dad   pgf #> pid_g 0.500 0.500 0.25 0.25 0.125 #> pid   0.500 1.000 0.25 0.25 0.125 #> mom   0.250 0.250 1.00 0.00 0.000 #> dad   0.250 0.250 0.00 1.00 0.250 #> pgf   0.125 0.125 0.00 0.25 1.000 #>"},{"path":"https://emilmip.github.io/LTFGRS/reference/graph_based_covariance_construction_multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructing covariance matrix from local family graph for multi trait analysis — graph_based_covariance_construction_multi","title":"Constructing covariance matrix from local family graph for multi trait analysis — graph_based_covariance_construction_multi","text":"Function constructs genetic covariance matrix given graph around proband extracts threshold information graph.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/graph_based_covariance_construction_multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructing covariance matrix from local family graph for multi trait analysis — graph_based_covariance_construction_multi","text":"","code":"graph_based_covariance_construction_multi(   fid,   pid,   cur_proband_id,   cur_family_graph,   h2_vec,   genetic_corrmat,   phen_names,   add_ind = TRUE )"},{"path":"https://emilmip.github.io/LTFGRS/reference/graph_based_covariance_construction_multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructing covariance matrix from local family graph for multi trait analysis — graph_based_covariance_construction_multi","text":"fid Name column family ID pid Name column personal ID cur_proband_id id proband cur_family_graph local graph current proband h2_vec vector liability scale heritabilities genetic_corrmat matrix genetic correlations considered phenotypes. Must order h2_vec. phen_names Names phenotypes, given cur_family_graph. add_ind whether add genetic liability proband . Defaults true.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/graph_based_covariance_construction_multi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructing covariance matrix from local family graph for multi trait analysis — graph_based_covariance_construction_multi","text":"list three elements. first element temp_tbl, contains id current proband, family ID lower upper thresholds phenotypes. second element, cov, covariance matrix local graph centred current proband. third element newOrder, order ids pid phen_names pasted together, order can enforced elsewhere .","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/graph_based_covariance_construction_multi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructing covariance matrix from local family graph for multi trait analysis — graph_based_covariance_construction_multi","text":"","code":"fam <- data.frame( fam = c(1, 1, 1,1), id = c(\"pid\", \"mom\", \"dad\", \"pgf\"), dadcol = c(\"dad\", 0, \"pgf\", 0), momcol = c(\"mom\", 0, 0, 0))  thresholds <- data.frame(   id = c(\"pid\", \"mom\", \"dad\", \"pgf\"),   lower_1 = c(-Inf, -Inf, 0.8, 0.7),   upper_1 = c(0.8, 0.8, 0.8, 0.7),   lower_2 = c(-Inf, 0.3, -Inf, 0.2),   upper_2 = c(0.3, 0.3, 0.3, 0.2))  graph <- prepare_graph(fam, icol = \"id\", fcol = \"dadcol\",  mcol = \"momcol\", node_attributes = thresholds)  ntrait <- 2 genetic_corrmat <- matrix(0.2, ncol = ntrait, nrow = ntrait) diag(genetic_corrmat) <- 1 full_corrmat <- matrix(0.3, ncol = ntrait, nrow = ntrait) diag(full_corrmat) <- 1 h2_vec <- rep(0.6, ntrait)  graph_based_covariance_construction_multi(fid = \"fam\",                                           pid = \"id\",                                           cur_proband_id = \"pid\",                                           cur_family_graph = graph,                                           h2_vec = h2_vec,                                           genetic_corrmat = genetic_corrmat,                                           phen_names = c(\"1\", \"2\")) #> $temp_tbl #> # A tibble: 5 × 6 #>   fam   id    lower_1 lower_2 upper_1 upper_2 #>   <chr> <chr>   <dbl>   <dbl>   <dbl>   <dbl> #> 1 pid   pid_g  -Inf    -Inf     Inf     Inf   #> 2 pid   pid    -Inf    -Inf       0.8     0.3 #> 3 pid   mom    -Inf       0.3     0.8     0.3 #> 4 pid   dad       0.8  -Inf       0.8     0.3 #> 5 pid   pgf       0.7     0.2     0.7     0.2 #>  #> $cov #>         pid_g_1 pid_1 mom_1 dad_1 pgf_1 pid_g_2 pid_2 mom_2 dad_2 pgf_2 #> pid_g_1    0.60  0.60  0.30  0.30  0.15    0.12  0.12  0.06  0.06  0.03 #> pid_1      0.60  1.00  0.30  0.30  0.15    0.12  0.12  0.06  0.06  0.03 #> mom_1      0.30  0.30  1.00  0.00  0.00    0.06  0.06  0.12  0.00  0.00 #> dad_1      0.30  0.30  0.00  1.00  0.30    0.06  0.06  0.00  0.12  0.06 #> pgf_1      0.15  0.15  0.00  0.30  1.00    0.03  0.03  0.00  0.06  0.12 #> pid_g_2    0.12  0.12  0.06  0.06  0.03    0.60  0.60  0.30  0.30  0.15 #> pid_2      0.12  0.12  0.06  0.06  0.03    0.60  1.00  0.30  0.30  0.15 #> mom_2      0.06  0.06  0.12  0.00  0.00    0.30  0.30  1.00  0.00  0.00 #> dad_2      0.06  0.06  0.00  0.12  0.06    0.30  0.30  0.00  1.00  0.30 #> pgf_2      0.03  0.03  0.00  0.06  0.12    0.15  0.15  0.00  0.30  1.00 #>  #> $newOrder #>  [1] \"pid_g_1\" \"pid_1\"   \"mom_1\"   \"dad_1\"   \"pgf_1\"   \"pid_g_2\" \"pid_2\"   #>  [8] \"mom_2\"   \"dad_2\"   \"pgf_2\"   #>"},{"path":"https://emilmip.github.io/LTFGRS/reference/kendler.html","id":null,"dir":"Reference","previous_headings":"","what":"Title Kendler's FGRS — kendler","title":"Title Kendler's FGRS — kendler","text":"Title Kendler's FGRS","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/kendler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title Kendler's FGRS — kendler","text":"","code":"kendler(   .tbl = NULL,   family_graphs = NULL,   family_graphs_col = \"fam_graph\",   pid = \"pid\",   fid = \"fid\",   role = NULL,   dadcol,   momcol,   env_cor_sib = 1,   env_cor_f = 1,   env_cor_m = 1 )"},{"path":"https://emilmip.github.io/LTFGRS/reference/kendler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title Kendler's FGRS — kendler","text":".tbl matrix, list data frame can converted tibble. Must least five columns hold family identifier, personal identifier, role lower upper thresholds. Note role must one following abbreviations - g (Genetic component full liability) - o (Full liability) - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side). Defaults NULL. family_graphs tibble columns pid family_graph_col. See prepare_graph construction graphs. family graphs Defaults NULL. family_graphs_col Name column family graphs family_graphs. Defaults \"fam_graph\". pid string holding name column .tbl (family threshs) hold personal identifier(s). Defaults \"PID\". fid string holding name column .tbl family holds family identifier. Defaults \"fid\". role string holding name column .tbl holds role. role must chosen following list abbreviations - g (Genetic component full liability) - o (Full liability) - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side). Defaults \"role\". dadcol column name father family_graphs .tbl. momcol column name mother family_graphs .tbl. env_cor_sib Cohabitation effect, .e. Factor siblings weighted. Defaults 1. env_cor_f Cohabitation effect, .e. Factor father weighted. Defaults 1. env_cor_m Cohabitation effect, .e. Factor mother weighted. Defaults 1.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/kendler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title Kendler's FGRS — kendler","text":"tibble summary values used calculate kendler FGRS FGRS .","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/kendler.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Title Kendler's FGRS — kendler","text":"","code":"# See Vignettes."},{"path":"https://emilmip.github.io/LTFGRS/reference/kendler_family_calculations.html","id":null,"dir":"Reference","previous_headings":"","what":"Title Helper function for Kendler's FGRS — kendler_family_calculations","title":"Title Helper function for Kendler's FGRS — kendler_family_calculations","text":"Title Helper function Kendler's FGRS","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/kendler_family_calculations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title Helper function for Kendler's FGRS — kendler_family_calculations","text":"","code":"kendler_family_calculations(   tbl,   cov,   pid,   cur_dad_id,   cur_mom_id,   env_cor_sib = 1,   env_cor_f = 1,   env_cor_m = 1 )"},{"path":"https://emilmip.github.io/LTFGRS/reference/kendler_family_calculations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title Helper function for Kendler's FGRS — kendler_family_calculations","text":"tbl tibble columns cip, lower, upper, pid (personal identifier column). cov Kinship matrix proband first row column pid column name personal identifier cur_dad_id ID father (column name, actual ID) cur_mom_id ID mother (column name, actual ID) env_cor_sib Cohabitation effect, .e. Factor siblings weighted. Defaults 1. env_cor_f Cohabitation effect, .e. Factor father weighted. Defaults 1. env_cor_m Cohabitation effect, .e. Factor mother weighted. Defaults 1.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/kendler_family_calculations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title Helper function for Kendler's FGRS — kendler_family_calculations","text":"tibble family specific values required Kendler's FGRS calculation.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/kendler_family_calculations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Title Helper function for Kendler's FGRS — kendler_family_calculations","text":"","code":"# See Vignettes."},{"path":"https://emilmip.github.io/LTFGRS/reference/prepare_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct graph from register information — prepare_graph","title":"Construct graph from register information — prepare_graph","text":"prepare_graph constructs graph based mother, father, offspring links.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/prepare_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct graph from register information — prepare_graph","text":"","code":"prepare_graph(   .tbl,   icol,   fcol,   mcol,   node_attributes = NA,   missingID_patterns = \"^0$\" )"},{"path":"https://emilmip.github.io/LTFGRS/reference/prepare_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct graph from register information — prepare_graph","text":".tbl tibble columns icol, fcol, mcol. Additional columns attributes constructed graph. icol column name column proband ids. fcol column name column father ids. mcol column name column mother ids. node_attributes tibble icol additional information, sex, lower threshold, upper threshold. Used assign attributes node graph, e.g. lower upper thresholds individuals graph. missingID_patterns string missing values ID columns. Multiple values can used, must separated \"|\". Defaults \"^0$\". OBS: \"0\" enough, since relies regex.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/prepare_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct graph from register information — prepare_graph","text":"igraph object. (directed) graph object based links provided .tbl, potentially provided attributes stored node.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/prepare_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct graph from register information — prepare_graph","text":"","code":"fam <- data.frame(   id = c(\"pid\", \"mom\", \"dad\", \"pgf\"),   dadcol = c(\"dad\", 0, \"pgf\", 0),   momcol = c(\"mom\", 0, 0, 0))  thresholds <- data.frame(   id = c(\"pid\", \"mom\", \"dad\", \"pgf\"),   lower = c(-Inf, -Inf, 0.8, 0.7),   upper = c(0.8, 0.8, 0.8, 0.7))  prepare_graph(fam, icol = \"id\", fcol = \"dadcol\", mcol = \"momcol\", node_attributes = thresholds) #> IGRAPH 08b7562 DN-- 4 3 --  #> + attr: name (v/c), lower (v/n), upper (v/n) #> + edges from 08b7562 (vertex names): #> [1] dad->pid mom->pid pgf->dad"},{"path":"https://emilmip.github.io/LTFGRS/reference/prepare_thresholds.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate (personalised) thresholds based on CIPs. — prepare_thresholds","title":"Calculate (personalised) thresholds based on CIPs. — prepare_thresholds","text":"function prepares input estimate_liability calculating thresholds based stratified cumulative incidence proportions (CIPs) options interpolation ages CIP values. Given tibble families family members (stratified) CIPs, personalised thresholds calculated individual present .tbl. individual may multiple families, family.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/prepare_thresholds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate (personalised) thresholds based on CIPs. — prepare_thresholds","text":"","code":"prepare_thresholds(   .tbl,   CIP,   age_col,   CIP_merge_columns = c(\"sex\", \"birth_year\", \"age\"),   CIP_cip_col = \"cip\",   status_col = \"status\",   lower_equal_upper = FALSE,   personal_thr = FALSE,   fid_col = \"fid\",   personal_id_col = \"pid\",   interpolation = NULL,   bst.params = list(max_depth = 10, base_score = 0, nthread = 4, min_child_weight = 10),   min_CIP_value = 1e-05,   xgboost_itr = 30 )"},{"path":"https://emilmip.github.io/LTFGRS/reference/prepare_thresholds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate (personalised) thresholds based on CIPs. — prepare_thresholds","text":".tbl Tibble  family personal id columns, well CIP_merge_columns status. CIP Tibble population representative cumulative incidence proportions. CIP must contain columns CIP_merge_columns cIP_cip_col. age_col Name column age end follow-age diagnosis cases. CIP_merge_columns columns CIPs subset , e.g. CIPs birth_year, sex. CIP_cip_col Name column CIP values. status_col Column contains status family member. Coded 0 FALSE (control) 1 TRUE (case). lower_equal_upper upper lower threshold cases? Can used CIPs detailed, e.g. stratified birth year sex. personal_thr thresholds based stratified CIPs population prevalence? fid_col Column contains family ID. personal_id_col Column contains personal ID. interpolation Type interpolation, defaults NULL. bst.params List parameters pass xgboost. See xgboost documentation details. min_CIP_value Minimum cip value allow. low values may lead numerical instabilities. xgboost_itr Number iterations run xgboost .","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/prepare_thresholds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate (personalised) thresholds based on CIPs. — prepare_thresholds","text":"Tibble (personlised) thresholds family member (lower & upper), calculated cumulative incidence proportion individual (K_i), population prevalence within individuals CIP strata (K_pop; max value stratum). threshold potentially relevant information can added family graphs familywise_attach_attributes.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/prepare_thresholds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate (personalised) thresholds based on CIPs. — prepare_thresholds","text":"","code":"tbl = data.frame( fid = c(1, 1, 1, 1), pid = c(1, 2, 3, 4), role = c(\"o\", \"m\", \"f\", \"pgf\"), sex = c(1, 0, 1, 1), status = c(0, 0, 1, 1), age = c(22, 42, 48, 78), birth_year = 2023 - c(22, 42, 48, 78), aoo = c(NA, NA, 43, 45))  cip = data.frame( age = c(22, 42, 43, 45, 48, 78), birth_year = c(2001, 1981, 1975, 1945, 1975, 1945), sex = c(1, 0, 1, 1, 1, 1), cip = c(0.1, 0.2, 0.3, 0.3, 0.3, 0.4))  prepare_thresholds(.tbl = tbl, CIP = cip, age_col = \"age\", interpolation = NA) #>   fid pid role sex status age birth_year aoo cip       thr     lower     upper #> 1   1   1    o   1      0  22       2001  NA 0.1 1.2815516      -Inf 1.2815516 #> 2   1   2    m   0      0  42       1981  NA 0.2 0.8416212      -Inf 0.8416212 #> 3   1   3    f   1      1  48       1975  43 0.3 0.5244005 0.5244005       Inf #> 4   1   4  pgf   1      1  78       1945  45 0.4 0.2533471 0.2533471       Inf"},{"path":"https://emilmip.github.io/LTFGRS/reference/rtmvnorm.gibbs.html","id":null,"dir":"Reference","previous_headings":"","what":"Gibbs Sampler for the truncated multivariate normal distribution — rtmvnorm.gibbs","title":"Gibbs Sampler for the truncated multivariate normal distribution — rtmvnorm.gibbs","text":"rtmvnorm.gibbs implements Gibbs sampler truncated multivariate normal distribution covariance matrix covmat.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/rtmvnorm.gibbs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gibbs Sampler for the truncated multivariate normal distribution — rtmvnorm.gibbs","text":"","code":"rtmvnorm.gibbs(   n_sim = 1e+05,   covmat,   lower = -Inf,   upper,   fixed = (lower == upper),   out = c(1),   burn_in = 1000 )"},{"path":"https://emilmip.github.io/LTFGRS/reference/rtmvnorm.gibbs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gibbs Sampler for the truncated multivariate normal distribution — rtmvnorm.gibbs","text":"n_sim positive number representing number draws Gibbs sampler burn-.. Defaults 1e+05. covmat symmetric numeric matrix representing covariance matrix multivariate normal distribution. lower number numeric vector representing lower cutoff point(s) truncated normal distribution. length lower must 1 equal dimension multivariable normal distribution. Defaults -Inf. upper number numeric vector representing upper cutoff point(s) truncated normal distribution. Must greater equal lower. addition length upper must 1 equal dimension multivariable normal distribution. Defaults Inf. fixed logical scalar logical vector indicating variables fix. fixed vector, must length lower upper. Defaults TRUE lower equal upper FALSE otherwise. integer numeric vector indicating variables returned Gibbs sampler. = c(1), first variable (usually genetic component full liability first phenotype) estimated returned. = c(2), second variable (usually full liability) estimated returned. = c(1,2), first second variable estimated returned. Defaults c(1). burn_in number iterations count burn Gibbs sampler. Must non-negative. Defaults 1000.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/rtmvnorm.gibbs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gibbs Sampler for the truncated multivariate normal distribution — rtmvnorm.gibbs","text":"covmat symmetric numeric matrix, n_sim burn_in positive/non-negative numbers, numeric vector lower, upper fixed numbers vectors length required format, rtmvnorm.gibbs returns sampling values Gibbs sampler variables specified .","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/rtmvnorm.gibbs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gibbs Sampler for the truncated multivariate normal distribution — rtmvnorm.gibbs","text":"Given covariance matrix covmat lower upper cutoff points, function rtmvnorm.gibbs() can used perform Gibbs sampler truncated multivariable normal distribution. possible specify variables return Gibbs sampler, making convenient use estimating full liability genetic component full liability.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/rtmvnorm.gibbs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gibbs Sampler for the truncated multivariate normal distribution — rtmvnorm.gibbs","text":"Kotecha, J. H., & Djuric, P. M. (1999, March). Gibbs sampling approach generation truncated multivariate gaussian random variables. 1999 IEEE International Conference Acoustics, Speech, Signal Processing. Proceedings. ICASSP99 (Cat. . 99CH36258) (Vol. 3, pp. 1757-1760). IEEE. doi:10.1109/ICASSP.1999.756335 Wilhelm, S., & Manjunath, B. G. (2010). tmvtnorm: package truncated multivariate normal distribution. R Journal. doi:10.32614/RJ-2010-005","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/rtmvnorm.gibbs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gibbs Sampler for the truncated multivariate normal distribution — rtmvnorm.gibbs","text":"","code":"samp <- rtmvnorm.gibbs(10e3, covmat = matrix(c(1, 0.2, 0.2, 0.5), 2),                        lower = c(-Inf, 0), upper = c(0, Inf), out = 1:2)"},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate under the liability threshold model. — simulate_under_LTM","title":"Simulate under the liability threshold model. — simulate_under_LTM","text":"simulate_under_LTM simulates families thresholds liability threshold model given family structure variable number phenotypes.Please note possible simulate different family structures.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate under the liability threshold model. — simulate_under_LTM","text":"","code":"simulate_under_LTM(   fam_vec = c(\"m\", \"f\", \"s1\", \"mgm\", \"mgf\", \"pgm\", \"pgf\"),   n_fam = NULL,   add_ind = TRUE,   h2 = 0.5,   genetic_corrmat = NULL,   full_corrmat = NULL,   phen_names = NULL,   n_sim = 1000,   pop_prev = 0.1 )"},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate under the liability threshold model. — simulate_under_LTM","text":"fam_vec vector strings holding different family members. family members must represented strings following list: - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side).  Defaults c(\"m\",\"f\",\"s1\",\"mgm\",\"mgf\",\"pgm\",\"pgf\"). n_fam named vector holding desired number family members. See  setNames. names must picked list mentioned . Defaults NULL. add_ind logical scalar indicating whether genetic component full liability well full liability underlying target individual included covariance matrix. Defaults TRUE. h2 Either number numeric vector holding liability-scale heritability(ies) one phenotypes. entries h2 must non-negative. Note liability threshold model, heritabilities must also 1. Defaults 0.5. genetic_corrmat Either NULL numeric matrix holding genetic correlations desired phenotypes. Must specified, length(h2)\\(>0\\), ignored h2 number. diagonal entries genetic_corrmat must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. Defaults NULL. full_corrmat Either NULL numeric matrix holding full correlations desired phenotypes. Must specified, length(h2)\\(>0\\), ignored h2 number. diagonal entries full_corrmat must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. Defaults NULL. phen_names Either NULL character vector holding phenotype names. names used create row column names covariance matrix. Must specified, length(h2) \\(> 0\\), ignored h2 number. specified, names default phenotype1, phenotype2, etc. Defaults NULL. n_sim positive number representing number simulations. Defaults 1000. pop_prev Either number numeric vector holding population prevalence(s), .e. overall prevalence(s) population. entries pop_prev must positive smaller 1. Defaults 0.1.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate under the liability threshold model. — simulate_under_LTM","text":"either fam_vec n_fam used argument, required format, liability-scale heritability h2 number satisfying \\(0 \\leq h^2\\), n_sim strictly positive number, pop_prev positive number one, output list containing two tibbles. first tibble, sim_obs, holds simulated liabilities, disease status current age/age--onset family members n_sim families. second tibble, thresholds, holds family identifier, personal identifier, role (specified fam_vec n_fam) well lower upper thresholds individuals families. Note tibble format required estimate_liability. either fam_vec n_fam used argument required format, genetic_corrmat full_corrmat two numeric symmetric matrices satisfying diagonal entries one -diagonal entries -1 1, liability-scale heritabilities h2_vec numbers satisfying \\(0 \\leq h^2_i\\) \\(\\\\{1,...,n_pheno\\}\\), n_sim strictly positive number, pop_prev positive numeric vector entries one, output list containing following lists. first outer list, named first phenotype phen_names, holds tibble sim_obs, holds simulated liabilities, disease status current age/age--onset family members n_sim families first phenotype. first outer list, second outer list, named second phenotype phen_names, holds tibble sim_obs, holds  simulated liabilities, disease status current age/age--onset family members n_sim families second phenotype. list containing sim_obs phenotype phen_names. last list entry, thresholds, holds family identifier, personal identifier, role (specified fam_vec n_fam) well lower upper thresholds individuals families phenotypes. Note tibble format required estimate_liability. Finally, note neither fam_vec n_fam specified, function returns disease status, current age/age--onset, lower upper thresholds, well personal identifier single individual, namely individual consideration (called o). fam_vec n_fam defined, user asked ' decide two vectors use.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate under the liability threshold model. — simulate_under_LTM","text":"function can used simulate case-control status, current age age--onset well lower upper thresholds variable number phenotypes family members n_sim families. h2 number, simulate_under_LTM simulates case- control status, current age age--onset well thresholds single phenotype. However, h2 numeric vector, genetic_corrmat full_corrmat two symmetric correlation matrices, phen_names pop_prev numeric vectors holding phenotype names population prevalences, respectively, simulate_under_LTM simulates case-control status, current age age--onset well thresholds two (correlated) phenotypes. family members can specified using one two possible formats.","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate under the liability threshold model. — simulate_under_LTM","text":"","code":"simulate_under_LTM() #> $sim_obs #> # A tibble: 1,000 × 26 #>    fid         g       o      m        f      s1      mgm    mgf     pgm     pgf #>    <chr>   <dbl>   <dbl>  <dbl>    <dbl>   <dbl>    <dbl>  <dbl>   <dbl>   <dbl> #>  1 fid_1 -0.860   0.157  -1.55   1.24    -0.558  -0.00886 -2.53   0.590  -0.780  #>  2 fid_2 -0.474   0.646   0.865  0.464    0.812  -0.313    1.10  -0.406   0.885  #>  3 fid_3  1.58    2.97    0.225  1.34     0.917  -0.506    1.90   0.416   0.343  #>  4 fid_4  1.70    1.52    1.53   0.600    0.334   1.41    -0.328  1.35    0.0340 #>  5 fid_5 -0.552  -0.583   1.49  -0.172    2.14    0.249    2.70   0.0504  0.415  #>  6 fid_6 -0.0492  0.0242  1.43   0.00244 -0.716  -0.730   -1.44  -0.647   0.259  #>  7 fid_7  0.565   0.133   0.184  0.125   -0.0207 -0.367    1.86  -0.810   0.559  #>  8 fid_8 -1.24   -2.07    0.763 -0.619    0.893   0.0873   2.41   0.194   0.892  #>  9 fid_9 -0.475  -1.07   -0.986  0.0768   1.08   -1.23     0.431  1.74   -0.886  #> 10 fid_… -0.257  -0.843  -0.758 -1.44     0.751  -0.898    0.271  0.540  -1.42   #> # ℹ 990 more rows #> # ℹ 16 more variables: o_status <lgl>, m_status <lgl>, f_status <lgl>, #> #   s1_status <lgl>, mgm_status <lgl>, mgf_status <lgl>, pgm_status <lgl>, #> #   pgf_status <lgl>, o_aoo <dbl>, m_aoo <dbl>, f_aoo <dbl>, s1_aoo <dbl>, #> #   mgm_aoo <dbl>, mgf_aoo <dbl>, pgm_aoo <dbl>, pgf_aoo <dbl> #>  #> $thresholds #> # A tibble: 8,000 × 5 #>    fid    indiv_ID role    lower upper #>    <chr>  <chr>    <chr>   <dbl> <dbl> #>  1 fid_1  fid_1_1  o     -Inf     3.38 #>  2 fid_2  fid_2_1  o     -Inf     3.45 #>  3 fid_3  fid_3_1  o        2.99  2.99 #>  4 fid_4  fid_4_1  o        1.51  1.51 #>  5 fid_5  fid_5_1  o     -Inf     2.68 #>  6 fid_6  fid_6_1  o     -Inf     3.55 #>  7 fid_7  fid_7_1  o     -Inf     3.35 #>  8 fid_8  fid_8_1  o     -Inf     2.68 #>  9 fid_9  fid_9_1  o     -Inf     2.95 #> 10 fid_10 fid_10_1 o     -Inf     3.24 #> # ℹ 7,990 more rows #>   genetic_corrmat <- matrix(0.4, 3, 3) diag(genetic_corrmat) <- 1 full_corrmat <- matrix(0.6, 3, 3) diag(full_corrmat) <- 1  simulate_under_LTM(fam_vec = NULL, n_fam = stats::setNames(c(1,1,1,2,2), c(\"m\",\"mgm\",\"mgf\",\"s\",\"mhs\"))) #> $sim_obs #> # A tibble: 1,000 × 26 #>    fid          g       o      m    mgm     mgf     s1     s2    mhs1     mhs2 #>    <chr>    <dbl>   <dbl>  <dbl>  <dbl>   <dbl>  <dbl>  <dbl>   <dbl>    <dbl> #>  1 fid_1   0.597  -0.0736  0.593  1.54  -0.0975  2.15  -0.622 -0.312  -0.688   #>  2 fid_2   0.832   0.795   0.170 -1.32  -0.0514  0.145  0.222  0.960  -0.0251  #>  3 fid_3  -0.415  -1.25   -1.26   0.592 -1.93    0.646 -1.55  -1.73   -0.00565 #>  4 fid_4  -0.437  -0.176   0.127  0.416 -2.05   -0.108  0.154 -1.71   -1.06    #>  5 fid_5   0.0853  0.739   1.95   1.89   0.203   0.729  0.516  1.32    1.41    #>  6 fid_6   0.451  -0.0504 -0.412  1.03  -0.383   1.90   0.538  0.322   1.82    #>  7 fid_7   0.777  -0.190   0.466  1.26   0.809   0.885  0.855  0.514   0.722   #>  8 fid_8   0.746   0.709  -0.512 -0.568  1.73    0.929  1.02   1.60    1.26    #>  9 fid_9  -0.933  -0.470   0.644 -0.742  1.27   -0.323  0.564  0.0259 -0.945   #> 10 fid_10 -0.321  -0.428   0.319  0.892 -0.701  -0.309 -0.411  0.120   0.688   #> # ℹ 990 more rows #> # ℹ 16 more variables: o_status <lgl>, m_status <lgl>, mgm_status <lgl>, #> #   mgf_status <lgl>, s1_status <lgl>, s2_status <lgl>, mhs1_status <lgl>, #> #   mhs2_status <lgl>, o_aoo <dbl>, m_aoo <dbl>, mgm_aoo <dbl>, mgf_aoo <dbl>, #> #   s1_aoo <dbl>, s2_aoo <dbl>, mhs1_aoo <dbl>, mhs2_aoo <dbl> #>  #> $thresholds #> # A tibble: 8,000 × 5 #>    fid    indiv_ID role  lower upper #>    <chr>  <chr>    <chr> <dbl> <dbl> #>  1 fid_1  fid_1_1  o      -Inf  2.95 #>  2 fid_2  fid_2_1  o      -Inf  2.43 #>  3 fid_3  fid_3_1  o      -Inf  2.83 #>  4 fid_4  fid_4_1  o      -Inf  2.43 #>  5 fid_5  fid_5_1  o      -Inf  2.59 #>  6 fid_6  fid_6_1  o      -Inf  2.72 #>  7 fid_7  fid_7_1  o      -Inf  3.52 #>  8 fid_8  fid_8_1  o      -Inf  3.28 #>  9 fid_9  fid_9_1  o      -Inf  2.47 #> 10 fid_10 fid_10_1 o      -Inf  3.42 #> # ℹ 7,990 more rows #>   simulate_under_LTM(fam_vec = c(\"m\",\"f\",\"s1\"), n_fam = NULL, add_ind = FALSE, genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat, n_sim = 200) #> $sim_obs #> # A tibble: 200 × 10 #>    fid          m       f     s1 m_status f_status s1_status m_aoo f_aoo s1_aoo #>    <chr>    <dbl>   <dbl>  <dbl> <lgl>    <lgl>    <lgl>     <dbl> <dbl>  <dbl> #>  1 fid_1   0.971   1.48   -1.11  FALSE    TRUE     FALSE        48    66     21 #>  2 fid_2  -1.35   -0.244  -0.397 FALSE    FALSE    FALSE        65    58     35 #>  3 fid_3   0.183   1.14    0.694 FALSE    FALSE    FALSE        31    41     12 #>  4 fid_4  -1.08    0.318  -0.455 FALSE    FALSE    FALSE        66    64     39 #>  5 fid_5  -0.434   1.98    0.923 FALSE    TRUE     FALSE        51    51     27 #>  6 fid_6  -0.0308  1.24   -1.67  FALSE    FALSE    FALSE        41    36     14 #>  7 fid_7   0.0450  1.94    0.556 FALSE    TRUE     FALSE        35    52     17 #>  8 fid_8  -0.446  -0.0383 -0.843 FALSE    FALSE    FALSE        58    63     35 #>  9 fid_9  -0.485   0.485  -0.221 FALSE    FALSE    FALSE        41    39     14 #> 10 fid_10 -0.230  -0.0316 -1.08  FALSE    FALSE    FALSE        39    33     15 #> # ℹ 190 more rows #>  #> $thresholds #> # A tibble: 600 × 5 #>    fid    indiv_ID role  lower upper #>    <chr>  <chr>    <chr> <dbl> <dbl> #>  1 fid_1  fid_1_1  m      -Inf  2.09 #>  2 fid_2  fid_2_1  m      -Inf  1.51 #>  3 fid_3  fid_3_1  m      -Inf  2.79 #>  4 fid_4  fid_4_1  m      -Inf  1.49 #>  5 fid_5  fid_5_1  m      -Inf  1.97 #>  6 fid_6  fid_6_1  m      -Inf  2.39 #>  7 fid_7  fid_7_1  m      -Inf  2.63 #>  8 fid_8  fid_8_1  m      -Inf  1.71 #>  9 fid_9  fid_9_1  m      -Inf  2.39 #> 10 fid_10 fid_10_1 m      -Inf  2.47 #> # ℹ 590 more rows #>   simulate_under_LTM(fam_vec = c(), n_fam = NULL, add_ind = TRUE, h2 = 0.5, n_sim = 200, pop_prev = 0.05) #> Warning: Neither fam_vec nor n_fam is specified... #> $sim_obs #> # A tibble: 200 × 5 #>    fid         g       o o_status o_aoo #>    <chr>   <dbl>   <dbl> <lgl>    <dbl> #>  1 fid_1   1.31   0.0869 FALSE       30 #>  2 fid_2   0.280 -0.648  FALSE       13 #>  3 fid_3   0.406  0.487  FALSE       15 #>  4 fid_4   0.873  0.103  FALSE       21 #>  5 fid_5   0.578  0.407  FALSE       21 #>  6 fid_6   0.108  0.767  FALSE       40 #>  7 fid_7   0.603 -1.09   FALSE       19 #>  8 fid_8   0.133 -0.936  FALSE       23 #>  9 fid_9  -0.301 -0.173  FALSE       13 #> 10 fid_10  1.72   2.58   TRUE        42 #> # ℹ 190 more rows #>  #> $thresholds #> # A tibble: 200 × 5 #>    fid    indiv_ID role    lower upper #>    <chr>  <chr>    <chr>   <dbl> <dbl> #>  1 fid_1  fid_1_1  o     -Inf     3.05 #>  2 fid_2  fid_2_1  o     -Inf     3.63 #>  3 fid_3  fid_3_1  o     -Inf     3.57 #>  4 fid_4  fid_4_1  o     -Inf     3.37 #>  5 fid_5  fid_5_1  o     -Inf     3.37 #>  6 fid_6  fid_6_1  o     -Inf     2.67 #>  7 fid_7  fid_7_1  o     -Inf     3.44 #>  8 fid_8  fid_8_1  o     -Inf     3.30 #>  9 fid_9  fid_9_1  o     -Inf     3.63 #> 10 fid_10 fid_10_1 o        2.59  2.59 #> # ℹ 190 more rows #>"},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM_multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate under the liability threshold model (multiple phenotypes). — simulate_under_LTM_multi","title":"Simulate under the liability threshold model (multiple phenotypes). — simulate_under_LTM_multi","text":"simulate_under_LTM_multi simulates families thresholds liability threshold model given family structure multiple phenotypes. Please note possible simulate different family structures.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM_multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate under the liability threshold model (multiple phenotypes). — simulate_under_LTM_multi","text":"","code":"simulate_under_LTM_multi(   fam_vec = c(\"m\", \"f\", \"s1\", \"mgm\", \"mgf\", \"pgm\", \"pgf\"),   n_fam = NULL,   add_ind = TRUE,   genetic_corrmat = diag(3),   full_corrmat = diag(3),   h2_vec = rep(0.5, 3),   phen_names = NULL,   n_sim = 1000,   pop_prev = rep(0.1, 3) )"},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM_multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate under the liability threshold model (multiple phenotypes). — simulate_under_LTM_multi","text":"fam_vec vector strings holding different family members. family members must represented strings following list: - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side).  Defaults c(\"m\",\"f\",\"s1\",\"mgm\",\"mgf\",\"pgm\",\"pgf\"). n_fam named vector holding desired number family members. See  setNames. names must picked list mentioned . Defaults NULL. add_ind logical scalar indicating whether genetic component full liability well full liability underlying target individual included covariance matrix. Defaults TRUE. genetic_corrmat numeric matrix holding genetic correlations desired phenotypes. diagonal entries must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. Defaults diag(3). full_corrmat numeric matrix holding full correlations desired phenotypes. diagonal entries must equal one, -diagonal entries must -1 1. addition, matrix must symmetric. Defaults diag(3). h2_vec numeric vector holding liability-scale heritabilities number phenotype. entries must non-negative. Note liability threshold model, heritabilities must also 1. Defaults rep(0.5,3). phen_names character vector holding phenotype names. names used create row column names covariance matrix. specified, names default phenotype1, phenotype2, etc. Defaults NULL. n_sim positive number representing number simulations. Defaults 1000. pop_prev numeric vector holding population prevalences, .e. overall prevalences population. entries pop_prev must positive smaller 1. Defaults rep(.1,3).","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM_multi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate under the liability threshold model (multiple phenotypes). — simulate_under_LTM_multi","text":"either fam_vec n_fam used argument required format, genetic_corrmat full_corrmat two numeric symmetric matrices satisfying diagonal entries one -diagonal entries -1 1, liability-scale heritabilities h2_vec numbers satisfying \\(0 \\leq h^2_i\\) \\(\\\\{1,...,n_pheno\\}\\), n_sim strictly positive number, pop_prev positive numeric vector entries one, output list containing lists phenotype. first outer list, named first phenotype phen_names, holds tibble sim_obs, holds simulated liabilities, disease status current age/age--onset family members n_sim families first phenotype. first outer list, second outer list, named second phenotype phen_names, holds tibble sim_obs, holds  simulated liabilities, disease status current age/age--onset family members n_sim families second phenotype. list containing sim_obs phenotype phen_names. last list entry, thresholds, holds family identifier, personal identifier, role (specified fam_vec n_fam) well lower upper thresholds individuals families phenotypes. Note tibble format required estimate_liability. Finally, note neither fam_vec n_fam specified, function returns disease status, current age/age--onset, lower upper thresholds, well personal identifier single individual, namely individual consideration (called o). fam_vec n_fam defined, user asked ' decide two vectors use.","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM_multi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate under the liability threshold model (multiple phenotypes). — simulate_under_LTM_multi","text":"","code":"simulate_under_LTM_multi() #> $phenotype1 #> $phenotype1$sim_obs #> # A tibble: 1,000 × 26 #>    fid    g_phenotype1 o_phenotype1 m_phenotype1 f_phenotype1 s1_phenotype1 #>    <chr>         <dbl>        <dbl>        <dbl>        <dbl>         <dbl> #>  1 fid_1         1.32         0.552        0.832      -0.447         1.35   #>  2 fid_2        -0.256        0.512        1.91       -1.40         -0.544  #>  3 fid_3         0.385        0.376       -0.297      -1.45         -1.68   #>  4 fid_4        -0.209       -0.436        0.881      -0.580         0.201  #>  5 fid_5         0.338       -0.366       -1.64        0.0718       -0.774  #>  6 fid_6        -0.820       -1.94        -0.150      -0.828         1.34   #>  7 fid_7         0.440       -0.247        0.638       1.38         -1.51   #>  8 fid_8         0.148        0.571        0.832       0.224         1.44   #>  9 fid_9         1.27         1.38        -0.775       1.81          0.0458 #> 10 fid_10        0.597        1.66         1.92       -0.0697       -0.464  #> # ℹ 990 more rows #> # ℹ 20 more variables: mgm_phenotype1 <dbl>, mgf_phenotype1 <dbl>, #> #   pgm_phenotype1 <dbl>, pgf_phenotype1 <dbl>, o_phenotype1_status <lgl>, #> #   m_phenotype1_status <lgl>, f_phenotype1_status <lgl>, #> #   s1_phenotype1_status <lgl>, mgm_phenotype1_status <lgl>, #> #   mgf_phenotype1_status <lgl>, pgm_phenotype1_status <lgl>, #> #   pgf_phenotype1_status <lgl>, o_phenotype1_aoo <dbl>, … #>  #>  #> $phenotype2 #> $phenotype2$sim_obs #> # A tibble: 1,000 × 26 #>    fid    g_phenotype2 o_phenotype2 m_phenotype2 f_phenotype2 s1_phenotype2 #>    <chr>         <dbl>        <dbl>        <dbl>        <dbl>         <dbl> #>  1 fid_1        0.296       -0.174         0.738       1.72         -0.0785 #>  2 fid_2        0.0747       0.695         0.688      -1.07          0.290  #>  3 fid_3        0.941        0.852         0.558      -0.0449        1.64   #>  4 fid_4        0.146       -0.0504        0.933       0.239        -0.783  #>  5 fid_5        0.419        1.10         -0.169      -0.488         0.892  #>  6 fid_6       -0.331       -0.489        -0.317       1.14         -0.271  #>  7 fid_7       -0.607       -0.599        -0.811      -0.544         1.54   #>  8 fid_8        0.0910       0.641        -1.78        0.896        -1.44   #>  9 fid_9       -0.500       -0.564        -0.664      -0.198        -1.39   #> 10 fid_10      -0.486        0.113        -0.446       0.741         0.588  #> # ℹ 990 more rows #> # ℹ 20 more variables: mgm_phenotype2 <dbl>, mgf_phenotype2 <dbl>, #> #   pgm_phenotype2 <dbl>, pgf_phenotype2 <dbl>, o_phenotype2_status <lgl>, #> #   m_phenotype2_status <lgl>, f_phenotype2_status <lgl>, #> #   s1_phenotype2_status <lgl>, mgm_phenotype2_status <lgl>, #> #   mgf_phenotype2_status <lgl>, pgm_phenotype2_status <lgl>, #> #   pgf_phenotype2_status <lgl>, o_phenotype2_aoo <dbl>, … #>  #>  #> $phenotype3 #> $phenotype3$sim_obs #> # A tibble: 1,000 × 26 #>    fid    g_phenotype3 o_phenotype3 m_phenotype3 f_phenotype3 s1_phenotype3 #>    <chr>         <dbl>        <dbl>        <dbl>        <dbl>         <dbl> #>  1 fid_1       -1.88        -1.69         -1.16        -1.76         -2.44  #>  2 fid_2       -0.277        0.537         1.15        -0.760        -0.537 #>  3 fid_3       -0.857       -1.19         -0.865        0.981        -1.52  #>  4 fid_4        0.633        1.36         -0.811        0.343         0.907 #>  5 fid_5        0.362        1.30          1.08         0.222         0.806 #>  6 fid_6        0.597       -0.130         0.188        0.780         0.954 #>  7 fid_7        0.106       -0.0109        0.239        1.14          1.44  #>  8 fid_8        1.03         1.61          0.277       -0.334        -0.329 #>  9 fid_9       -0.442       -0.764         1.30         0.332         0.703 #> 10 fid_10      -0.0873       0.607         0.662       -1.18         -0.518 #> # ℹ 990 more rows #> # ℹ 20 more variables: mgm_phenotype3 <dbl>, mgf_phenotype3 <dbl>, #> #   pgm_phenotype3 <dbl>, pgf_phenotype3 <dbl>, o_phenotype3_status <lgl>, #> #   m_phenotype3_status <lgl>, f_phenotype3_status <lgl>, #> #   s1_phenotype3_status <lgl>, mgm_phenotype3_status <lgl>, #> #   mgf_phenotype3_status <lgl>, pgm_phenotype3_status <lgl>, #> #   pgf_phenotype3_status <lgl>, o_phenotype3_aoo <dbl>, … #>  #>  #> $thresholds #> # A tibble: 8,000 × 9 #>    fid    indiv_ID role  lower_phenotype1 upper_phenotype1 lower_phenotype2 #>    <chr>  <chr>    <chr>            <dbl>            <dbl>            <dbl> #>  1 fid_1  fid_1_1  o              -Inf                2.68             -Inf #>  2 fid_2  fid_2_1  o              -Inf                2.95             -Inf #>  3 fid_3  fid_3_1  o              -Inf                3.17             -Inf #>  4 fid_4  fid_4_1  o              -Inf                3.38             -Inf #>  5 fid_5  fid_5_1  o              -Inf                2.79             -Inf #>  6 fid_6  fid_6_1  o              -Inf                2.63             -Inf #>  7 fid_7  fid_7_1  o              -Inf                3.17             -Inf #>  8 fid_8  fid_8_1  o              -Inf                2.55             -Inf #>  9 fid_9  fid_9_1  o                 1.38             1.38             -Inf #> 10 fid_10 fid_10_1 o                 1.64             1.64             -Inf #> # ℹ 7,990 more rows #> # ℹ 3 more variables: upper_phenotype2 <dbl>, lower_phenotype3 <dbl>, #> #   upper_phenotype3 <dbl> #>   genetic_corrmat <- matrix(0.4, 3, 3) diag(genetic_corrmat) <- 1 full_corrmat <- matrix(0.6, 3, 3) diag(full_corrmat) <- 1  simulate_under_LTM_multi(fam_vec = NULL, n_fam = stats::setNames(c(1,1,1,2,2), c(\"m\",\"mgm\",\"mgf\",\"s\",\"mhs\"))) #> $phenotype1 #> $phenotype1$sim_obs #> # A tibble: 1,000 × 26 #>    fid    g_phenotype1 o_phenotype1 m_phenotype1 mgm_phenotype1 mgf_phenotype1 #>    <chr>         <dbl>        <dbl>        <dbl>          <dbl>          <dbl> #>  1 fid_1         0.582       -0.122       -0.218          0.474         -1.15  #>  2 fid_2         1.08         1.11         2.50           1.06           2.22  #>  3 fid_3         0.318       -0.102        0.671          0.922          1.27  #>  4 fid_4         0.764        1.21         0.518          0.948          2.11  #>  5 fid_5        -0.666       -0.965       -0.558         -0.720         -0.618 #>  6 fid_6        -1.46        -2.27        -1.79          -0.225         -0.894 #>  7 fid_7         0.561        1.31         0.470          1.11           1.31  #>  8 fid_8         0.651        1.13         1.33           0.535          0.310 #>  9 fid_9        -0.632        0.133        0.854          0.744         -0.963 #> 10 fid_10       -0.735       -0.785       -0.819          0.610          0.401 #> # ℹ 990 more rows #> # ℹ 20 more variables: s1_phenotype1 <dbl>, s2_phenotype1 <dbl>, #> #   mhs1_phenotype1 <dbl>, mhs2_phenotype1 <dbl>, o_phenotype1_status <lgl>, #> #   m_phenotype1_status <lgl>, mgm_phenotype1_status <lgl>, #> #   mgf_phenotype1_status <lgl>, s1_phenotype1_status <lgl>, #> #   s2_phenotype1_status <lgl>, mhs1_phenotype1_status <lgl>, #> #   mhs2_phenotype1_status <lgl>, o_phenotype1_aoo <dbl>, … #>  #>  #> $phenotype2 #> $phenotype2$sim_obs #> # A tibble: 1,000 × 26 #>    fid    g_phenotype2 o_phenotype2 m_phenotype2 mgm_phenotype2 mgf_phenotype2 #>    <chr>         <dbl>        <dbl>        <dbl>          <dbl>          <dbl> #>  1 fid_1       -0.322        0.675       -0.316          1.47            0.468 #>  2 fid_2       -0.590       -0.585        0.495         -1.18            0.542 #>  3 fid_3       -0.0328      -0.0405       0.270         -0.0274         -1.03  #>  4 fid_4        0.530        1.09        -0.723          0.487          -1.19  #>  5 fid_5        0.763        0.669        1.53           0.490           0.856 #>  6 fid_6       -0.489       -3.04         0.0696         0.357           0.697 #>  7 fid_7       -0.660       -0.803       -0.0668         1.74           -3.72  #>  8 fid_8        0.759        0.752        0.515         -2.06            0.617 #>  9 fid_9        0.923        0.475        1.92           0.317           1.30  #> 10 fid_10      -1.10        -0.984       -1.70          -1.23           -0.828 #> # ℹ 990 more rows #> # ℹ 20 more variables: s1_phenotype2 <dbl>, s2_phenotype2 <dbl>, #> #   mhs1_phenotype2 <dbl>, mhs2_phenotype2 <dbl>, o_phenotype2_status <lgl>, #> #   m_phenotype2_status <lgl>, mgm_phenotype2_status <lgl>, #> #   mgf_phenotype2_status <lgl>, s1_phenotype2_status <lgl>, #> #   s2_phenotype2_status <lgl>, mhs1_phenotype2_status <lgl>, #> #   mhs2_phenotype2_status <lgl>, o_phenotype2_aoo <dbl>, … #>  #>  #> $phenotype3 #> $phenotype3$sim_obs #> # A tibble: 1,000 × 26 #>    fid    g_phenotype3 o_phenotype3 m_phenotype3 mgm_phenotype3 mgf_phenotype3 #>    <chr>         <dbl>        <dbl>        <dbl>          <dbl>          <dbl> #>  1 fid_1         0.811        0.875       1.54           -0.968          0.745 #>  2 fid_2         0.283       -0.621       0.0988          0.136          1.89  #>  3 fid_3         1.08         1.17        0.942           1.90           0.296 #>  4 fid_4        -0.744       -0.403       0.800           0.779          0.194 #>  5 fid_5         0.193        0.834       1.95            1.96          -0.405 #>  6 fid_6         0.976       -0.181      -1.57           -0.747          1.37  #>  7 fid_7        -0.433       -0.607       0.810          -0.305         -1.38  #>  8 fid_8        -1.32        -0.564      -0.978          -0.802         -0.811 #>  9 fid_9         0.122        1.24        0.227          -1.21           2.45  #> 10 fid_10       -0.442       -0.494       0.890           1.62           1.42  #> # ℹ 990 more rows #> # ℹ 20 more variables: s1_phenotype3 <dbl>, s2_phenotype3 <dbl>, #> #   mhs1_phenotype3 <dbl>, mhs2_phenotype3 <dbl>, o_phenotype3_status <lgl>, #> #   m_phenotype3_status <lgl>, mgm_phenotype3_status <lgl>, #> #   mgf_phenotype3_status <lgl>, s1_phenotype3_status <lgl>, #> #   s2_phenotype3_status <lgl>, mhs1_phenotype3_status <lgl>, #> #   mhs2_phenotype3_status <lgl>, o_phenotype3_aoo <dbl>, … #>  #>  #> $thresholds #> # A tibble: 8,000 × 9 #>    fid    indiv_ID role  lower_phenotype1 upper_phenotype1 lower_phenotype2 #>    <chr>  <chr>    <chr>            <dbl>            <dbl>            <dbl> #>  1 fid_1  fid_1_1  o              -Inf                3.42             -Inf #>  2 fid_2  fid_2_1  o              -Inf                2.95             -Inf #>  3 fid_3  fid_3_1  o              -Inf                2.99             -Inf #>  4 fid_4  fid_4_1  o              -Inf                2.83             -Inf #>  5 fid_5  fid_5_1  o              -Inf                3.24             -Inf #>  6 fid_6  fid_6_1  o              -Inf                2.55             -Inf #>  7 fid_7  fid_7_1  o                 1.31             1.31             -Inf #>  8 fid_8  fid_8_1  o              -Inf                2.95             -Inf #>  9 fid_9  fid_9_1  o              -Inf                3.42             -Inf #> 10 fid_10 fid_10_1 o              -Inf                2.87             -Inf #> # ℹ 7,990 more rows #> # ℹ 3 more variables: upper_phenotype2 <dbl>, lower_phenotype3 <dbl>, #> #   upper_phenotype3 <dbl> #>   simulate_under_LTM_multi(fam_vec = c(\"m\",\"f\",\"s1\"), add_ind = FALSE, genetic_corrmat = genetic_corrmat, full_corrmat = full_corrmat, n_sim = 100) #> $phenotype1 #> $phenotype1$sim_obs #> # A tibble: 100 × 10 #>    fid    m_phenotype1 f_phenotype1 s1_phenotype1 m_phenotype1_status #>    <chr>         <dbl>        <dbl>         <dbl> <lgl>               #>  1 fid_1        -0.544        1.66          0.825 FALSE               #>  2 fid_2        -1.21         1.89          0.351 FALSE               #>  3 fid_3         1.75         0.466         3.35  TRUE                #>  4 fid_4        -0.592        1.06          1.73  FALSE               #>  5 fid_5        -0.329       -0.182         1.72  FALSE               #>  6 fid_6        -1.29        -1.07          0.427 FALSE               #>  7 fid_7        -0.525       -1.34          0.144 FALSE               #>  8 fid_8        -0.187       -0.441         0.687 FALSE               #>  9 fid_9        -1.40         1.55         -1.52  FALSE               #> 10 fid_10       -0.804       -0.803        -1.52  FALSE               #> # ℹ 90 more rows #> # ℹ 5 more variables: f_phenotype1_status <lgl>, s1_phenotype1_status <lgl>, #> #   m_phenotype1_aoo <dbl>, f_phenotype1_aoo <dbl>, s1_phenotype1_aoo <dbl> #>  #>  #> $phenotype2 #> $phenotype2$sim_obs #> # A tibble: 100 × 10 #>    fid    m_phenotype2 f_phenotype2 s1_phenotype2 m_phenotype2_status #>    <chr>         <dbl>        <dbl>         <dbl> <lgl>               #>  1 fid_1        -0.752       0.129         0.444  FALSE               #>  2 fid_2         2.26        0.218         0.923  TRUE                #>  3 fid_3         0.385       0.0167        2.04   FALSE               #>  4 fid_4         0.849      -0.380        -0.0785 FALSE               #>  5 fid_5        -0.871       0.705         1.17   FALSE               #>  6 fid_6        -0.706      -2.17         -0.990  FALSE               #>  7 fid_7         0.102      -1.28         -0.330  FALSE               #>  8 fid_8         0.919       0.285        -1.43   FALSE               #>  9 fid_9        -0.949       0.590        -1.70   FALSE               #> 10 fid_10        0.610      -0.603        -1.71   FALSE               #> # ℹ 90 more rows #> # ℹ 5 more variables: f_phenotype2_status <lgl>, s1_phenotype2_status <lgl>, #> #   m_phenotype2_aoo <dbl>, f_phenotype2_aoo <dbl>, s1_phenotype2_aoo <dbl> #>  #>  #> $phenotype3 #> $phenotype3$sim_obs #> # A tibble: 100 × 10 #>    fid    m_phenotype3 f_phenotype3 s1_phenotype3 m_phenotype3_status #>    <chr>         <dbl>        <dbl>         <dbl> <lgl>               #>  1 fid_1        -0.994       -0.518        0.218  FALSE               #>  2 fid_2        -0.351        1.66         0.541  FALSE               #>  3 fid_3         0.382        0.569        2.63   FALSE               #>  4 fid_4         1.18         0.188        0.134  FALSE               #>  5 fid_5         1.01         0.532        2.20   FALSE               #>  6 fid_6        -1.08        -0.645        0.187  FALSE               #>  7 fid_7         0.565       -2.77        -1.19   FALSE               #>  8 fid_8        -0.959        0.303       -0.0441 FALSE               #>  9 fid_9         1.52         0.190       -0.971  TRUE                #> 10 fid_10       -0.955       -0.788       -2.12   FALSE               #> # ℹ 90 more rows #> # ℹ 5 more variables: f_phenotype3_status <lgl>, s1_phenotype3_status <lgl>, #> #   m_phenotype3_aoo <dbl>, f_phenotype3_aoo <dbl>, s1_phenotype3_aoo <dbl> #>  #>  #> $thresholds #> # A tibble: 300 × 9 #>    fid    indiv_ID role  lower_phenotype1 upper_phenotype1 lower_phenotype2 #>    <chr>  <chr>    <chr>            <dbl>            <dbl>            <dbl> #>  1 fid_1  fid_1_1  m              -Inf                1.71          -Inf    #>  2 fid_2  fid_2_1  m              -Inf                2.26             2.26 #>  3 fid_3  fid_3_1  m                 1.74             1.74          -Inf    #>  4 fid_4  fid_4_1  m              -Inf                2.47          -Inf    #>  5 fid_5  fid_5_1  m              -Inf                2.22          -Inf    #>  6 fid_6  fid_6_1  m              -Inf                1.68          -Inf    #>  7 fid_7  fid_7_1  m              -Inf                2.34          -Inf    #>  8 fid_8  fid_8_1  m              -Inf                1.78          -Inf    #>  9 fid_9  fid_9_1  m              -Inf                1.71          -Inf    #> 10 fid_10 fid_10_1 m              -Inf                1.89          -Inf    #> # ℹ 290 more rows #> # ℹ 3 more variables: upper_phenotype2 <dbl>, lower_phenotype3 <dbl>, #> #   upper_phenotype3 <dbl> #>   simulate_under_LTM_multi(fam_vec = c(), n_fam = NULL, add_ind = TRUE, n_sim = 150) #> $phenotype1 #> $phenotype1$sim_obs #> # A tibble: 150 × 5 #>    fid    g_phenotype1 o_phenotype1 o_phenotype1_status o_phenotype1_aoo #>    <chr>         <dbl>        <dbl> <lgl>                          <dbl> #>  1 fid_1         0.126       0.495  FALSE                             20 #>  2 fid_2         0.805       0.747  FALSE                             14 #>  3 fid_3         0.848       1.71   TRUE                              58 #>  4 fid_4         0.596       0.0853 FALSE                             38 #>  5 fid_5         0.773       0.551  FALSE                             35 #>  6 fid_6        -0.322       1.26   FALSE                             20 #>  7 fid_7         0.212       0.236  FALSE                             24 #>  8 fid_8        -0.449       0.214  FALSE                             18 #>  9 fid_9         0.161       0.600  FALSE                             15 #> 10 fid_10        1.05        1.46   TRUE                              68 #> # ℹ 140 more rows #>  #>  #> $phenotype2 #> $phenotype2$sim_obs #> # A tibble: 150 × 5 #>    fid    g_phenotype2 o_phenotype2 o_phenotype2_status o_phenotype2_aoo #>    <chr>         <dbl>        <dbl> <lgl>                          <dbl> #>  1 fid_1        -0.133      -0.617  FALSE                             20 #>  2 fid_2         0.804       0.885  FALSE                             14 #>  3 fid_3         0.939       0.765  FALSE                             38 #>  4 fid_4        -2.54       -2.86   FALSE                             38 #>  5 fid_5        -0.684      -0.399  FALSE                             35 #>  6 fid_6         0.456      -0.255  FALSE                             20 #>  7 fid_7        -0.822       0.0780 FALSE                             24 #>  8 fid_8        -0.874      -0.723  FALSE                             18 #>  9 fid_9         0.773       1.28   FALSE                             15 #> 10 fid_10        1.38        0.282  FALSE                             18 #> # ℹ 140 more rows #>  #>  #> $phenotype3 #> $phenotype3$sim_obs #> # A tibble: 150 × 5 #>    fid    g_phenotype3 o_phenotype3 o_phenotype3_status o_phenotype3_aoo #>    <chr>         <dbl>        <dbl> <lgl>                          <dbl> #>  1 fid_1         0.898      1.24    FALSE                             20 #>  2 fid_2        -0.121     -0.00243 FALSE                             14 #>  3 fid_3         1.26       1.57    TRUE                              63 #>  4 fid_4        -0.181     -0.0490  FALSE                             38 #>  5 fid_5         0.358     -0.479   FALSE                             35 #>  6 fid_6        -0.676     -0.265   FALSE                             20 #>  7 fid_7        -1.83      -2.00    FALSE                             24 #>  8 fid_8        -0.489     -0.175   FALSE                             18 #>  9 fid_9         0.530      0.613   FALSE                             15 #> 10 fid_10        0.606      0.0891  FALSE                             18 #> # ℹ 140 more rows #>  #>  #> $thresholds #> # A tibble: 150 × 9 #>    fid    indiv_ID role  lower_phenotype1 upper_phenotype1 lower_phenotype2 #>    <chr>  <chr>    <chr>            <dbl>            <dbl>            <dbl> #>  1 fid_1  fid_1_1  o              -Inf                3.21             -Inf #>  2 fid_2  fid_2_1  o              -Inf                3.42             -Inf #>  3 fid_3  fid_3_1  o                 1.71             1.71             -Inf #>  4 fid_4  fid_4_1  o              -Inf                2.51             -Inf #>  5 fid_5  fid_5_1  o              -Inf                2.63             -Inf #>  6 fid_6  fid_6_1  o              -Inf                3.21             -Inf #>  7 fid_7  fid_7_1  o              -Inf                3.06             -Inf #>  8 fid_8  fid_8_1  o              -Inf                3.28             -Inf #>  9 fid_9  fid_9_1  o              -Inf                3.38             -Inf #> 10 fid_10 fid_10_1 o                 1.45             1.45             -Inf #> # ℹ 140 more rows #> # ℹ 3 more variables: upper_phenotype2 <dbl>, lower_phenotype3 <dbl>, #> #   upper_phenotype3 <dbl> #>"},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM_single.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate under the liability threshold model (single phenotype). — simulate_under_LTM_single","title":"Simulate under the liability threshold model (single phenotype). — simulate_under_LTM_single","text":"simulate_under_LTM_single simulates families thresholds liability threshold model given family structure single phenotype. Please note possible simulate different family structures.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM_single.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate under the liability threshold model (single phenotype). — simulate_under_LTM_single","text":"","code":"simulate_under_LTM_single(   fam_vec = c(\"m\", \"f\", \"s1\", \"mgm\", \"mgf\", \"pgm\", \"pgf\"),   n_fam = NULL,   add_ind = TRUE,   h2 = 0.5,   n_sim = 1000,   pop_prev = 0.1 )"},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM_single.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate under the liability threshold model (single phenotype). — simulate_under_LTM_single","text":"fam_vec vector strings holding different family members. family members must represented strings following list: - m (Mother) - f (Father) - c[0-9]*.[0-9]* (Children) - mgm (Maternal grandmother) - mgf (Maternal grandfather) - pgm (Paternal grandmother) - pgf (Paternal grandfather) - s[0-9]* (Full siblings) - mhs[0-9]* (Half-siblings - maternal side) - phs[0-9]* (Half-siblings - paternal side) - mau[0-9]* (Aunts/Uncles - maternal side) - pau[0-9]* (Aunts/Uncles - paternal side).  Defaults c(\"m\",\"f\",\"s1\",\"mgm\",\"mgf\",\"pgm\",\"pgf\"). n_fam named vector holding desired number family members. See  setNames. names must picked list mentioned . Defaults NULL. add_ind logical scalar indicating whether genetic component full liability well full liability underlying target individual included covariance matrix. Defaults TRUE. h2 number representing liability-scale heritability single phenotype. Must non-negative. Note liability threshold model, heritability must also 1. Defaults 0.5. n_sim positive number representing number simulations. Defaults 1000. pop_prev positive number representing population prevalence, .e. overall prevalence population. Must smaller 1. Defaults 0.1.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM_single.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate under the liability threshold model (single phenotype). — simulate_under_LTM_single","text":"either fam_vec n_fam used argument, required format, liability-scale heritability h2 number satisfying \\(0 \\leq h^2\\), n_sim strictly positive number, pop_prev positive number one, output list holding two tibbles. first tibble, sim_obs, holds simulated liabilities, disease status current age/age--onset family members n_sim families. second tibble, thresholds, holds family identifier, personal identifier, role (specified fam_vec n_fam) well lower upper thresholds individuals families. Note tibble format required estimate_liability. addition, note neither fam_vec n_fam specified, function returns disease status, current age/age--onset, lower upper thresholds, well personal identifier single individual, namely individual consideration (called o). fam_vec n_fam defined, user asked ' decide two vectors use.","code":""},{"path":[]},{"path":"https://emilmip.github.io/LTFGRS/reference/simulate_under_LTM_single.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate under the liability threshold model (single phenotype). — simulate_under_LTM_single","text":"","code":"simulate_under_LTM_single() #> $sim_obs #> # A tibble: 1,000 × 26 #>    fid         g      o       m       f     s1    mgm     mgf    pgm    pgf #>    <chr>   <dbl>  <dbl>   <dbl>   <dbl>  <dbl>  <dbl>   <dbl>  <dbl>  <dbl> #>  1 fid_1   0.321  0.536 -0.0243  1.59    0.827 -1.07   0.0377  0.375  0.225 #>  2 fid_2   0.694  0.797  0.517  -0.639   0.245  0.214  1.28   -0.236 -0.144 #>  3 fid_3  -1.18  -1.83  -0.0783  0.171   0.349 -1.46   0.828   1.05  -1.62  #>  4 fid_4   0.229 -1.16   0.0353  0.237   1.79   2.19  -0.721   0.209  0.612 #>  5 fid_5   0.154 -1.14  -0.930  -0.384  -0.698 -1.36   0.392   0.751 -0.906 #>  6 fid_6  -0.665 -0.452 -1.63    0.416   1.52  -2.15  -0.986   0.134  1.72  #>  7 fid_7   0.563  0.438 -0.979   1.59   -0.521  1.81   0.807   0.172  1.55  #>  8 fid_8  -0.887 -1.42   1.14   -2.39   -0.307  0.960  0.390  -0.506 -0.407 #>  9 fid_9  -0.263 -0.929 -0.236  -0.0244  0.891 -0.336  0.320   0.341 -1.79  #> 10 fid_10 -0.673  0.673  0.198  -0.448  -1.64  -0.710  2.13   -0.230 -1.52  #> # ℹ 990 more rows #> # ℹ 16 more variables: o_status <lgl>, m_status <lgl>, f_status <lgl>, #> #   s1_status <lgl>, mgm_status <lgl>, mgf_status <lgl>, pgm_status <lgl>, #> #   pgf_status <lgl>, o_aoo <dbl>, m_aoo <dbl>, f_aoo <dbl>, s1_aoo <dbl>, #> #   mgm_aoo <dbl>, mgf_aoo <dbl>, pgm_aoo <dbl>, pgf_aoo <dbl> #>  #> $thresholds #> # A tibble: 8,000 × 5 #>    fid    indiv_ID role  lower upper #>    <chr>  <chr>    <chr> <dbl> <dbl> #>  1 fid_1  fid_1_1  o      -Inf  2.95 #>  2 fid_2  fid_2_1  o      -Inf  3.35 #>  3 fid_3  fid_3_1  o      -Inf  2.51 #>  4 fid_4  fid_4_1  o      -Inf  3.31 #>  5 fid_5  fid_5_1  o      -Inf  3.14 #>  6 fid_6  fid_6_1  o      -Inf  3.06 #>  7 fid_7  fid_7_1  o      -Inf  2.47 #>  8 fid_8  fid_8_1  o      -Inf  3.38 #>  9 fid_9  fid_9_1  o      -Inf  2.59 #> 10 fid_10 fid_10_1 o      -Inf  3.17 #> # ℹ 7,990 more rows #>  simulate_under_LTM_single(fam_vec = NULL, n_fam = stats::setNames(c(1,1,1,2), c(\"m\",\"mgm\",\"mgf\",\"mhs\"))) #> $sim_obs #> # A tibble: 1,000 × 20 #>    fid         g       o       m    mgm    mgf    mhs1    mhs2 o_status m_status #>    <chr>   <dbl>   <dbl>   <dbl>  <dbl>  <dbl>   <dbl>   <dbl> <lgl>    <lgl>    #>  1 fid_1 -1.38   -1.62   -1.35    1.79  -1.37  -1.71   -0.595  FALSE    FALSE    #>  2 fid_2  1.09    0.548   0.814  -0.357  0.750  0.970   0.618  FALSE    FALSE    #>  3 fid_3 -0.797  -1.22   -2.53   -2.15  -1.09  -0.584  -1.68   FALSE    FALSE    #>  4 fid_4  0.0998  1.08    0.527  -0.148 -0.758 -0.175   0.511  FALSE    FALSE    #>  5 fid_5 -1.05   -1.93   -0.0152 -0.693  0.841 -0.236   0.242  FALSE    FALSE    #>  6 fid_6  0.139   0.678  -1.00   -0.528 -1.73  -0.332  -0.118  FALSE    FALSE    #>  7 fid_7 -0.216  -1.56    0.671   0.103 -0.419 -0.0806 -0.0516 FALSE    FALSE    #>  8 fid_8  0.387  -0.0113  1.42    0.355  0.218 -0.0232 -0.885  FALSE    TRUE     #>  9 fid_9  0.557   1.84    0.823  -0.268  1.46   0.0325 -0.699  TRUE     FALSE    #> 10 fid_…  0.128   0.515   0.756   0.673 -0.163 -1.71    0.0366 FALSE    FALSE    #> # ℹ 990 more rows #> # ℹ 10 more variables: mgm_status <lgl>, mgf_status <lgl>, mhs1_status <lgl>, #> #   mhs2_status <lgl>, o_aoo <dbl>, m_aoo <dbl>, mgm_aoo <dbl>, mgf_aoo <dbl>, #> #   mhs1_aoo <dbl>, mhs2_aoo <dbl> #>  #> $thresholds #> # A tibble: 6,000 × 5 #>    fid    indiv_ID role    lower upper #>    <chr>  <chr>    <chr>   <dbl> <dbl> #>  1 fid_1  fid_1_1  o     -Inf     3.10 #>  2 fid_2  fid_2_1  o     -Inf     3.31 #>  3 fid_3  fid_3_1  o     -Inf     2.47 #>  4 fid_4  fid_4_1  o     -Inf     2.87 #>  5 fid_5  fid_5_1  o     -Inf     3.03 #>  6 fid_6  fid_6_1  o     -Inf     2.91 #>  7 fid_7  fid_7_1  o     -Inf     3.31 #>  8 fid_8  fid_8_1  o     -Inf     3.03 #>  9 fid_9  fid_9_1  o        1.85  1.85 #> 10 fid_10 fid_10_1 o     -Inf     2.87 #> # ℹ 5,990 more rows #>  simulate_under_LTM_single(fam_vec = c(\"m\",\"f\",\"s1\"), n_fam = NULL, add_ind = FALSE, h2 = 0.5, n_sim = 500, pop_prev = .05) #> $sim_obs #> # A tibble: 500 × 10 #>    fid          m       f      s1 m_status f_status s1_status m_aoo f_aoo s1_aoo #>    <chr>    <dbl>   <dbl>   <dbl> <lgl>    <lgl>    <lgl>     <dbl> <dbl>  <dbl> #>  1 fid_1   0.202  -0.753  -2.67   FALSE    FALSE    FALSE        44    40     17 #>  2 fid_2  -0.286   0.553  -0.0829 FALSE    FALSE    FALSE        65    62     38 #>  3 fid_3   0.0843  0.534  -0.326  FALSE    FALSE    FALSE        59    55     36 #>  4 fid_4  -1.43   -3.12   -2.17   FALSE    FALSE    FALSE        32    35     14 #>  5 fid_5   1.84    0.627   0.797  TRUE     FALSE    FALSE        65    48     19 #>  6 fid_6   0.261   2.17    0.359  FALSE    TRUE     FALSE        53    53     27 #>  7 fid_7  -0.297  -1.33    0.158  FALSE    FALSE    FALSE        56    45     26 #>  8 fid_8  -2.33    0.324   0.768  FALSE    FALSE    FALSE        46    40     20 #>  9 fid_9  -0.668   0.155  -1.04   FALSE    FALSE    FALSE        48    50     27 #> 10 fid_10 -0.607  -0.0234  0.953  FALSE    FALSE    FALSE        43    41     19 #> # ℹ 490 more rows #>  #> $thresholds #> # A tibble: 1,500 × 5 #>    fid    indiv_ID role    lower upper #>    <chr>  <chr>    <chr>   <dbl> <dbl> #>  1 fid_1  fid_1_1  m     -Inf     2.51 #>  2 fid_2  fid_2_1  m     -Inf     1.84 #>  3 fid_3  fid_3_1  m     -Inf     1.99 #>  4 fid_4  fid_4_1  m     -Inf     2.97 #>  5 fid_5  fid_5_1  m        1.84  1.84 #>  6 fid_6  fid_6_1  m     -Inf     2.18 #>  7 fid_7  fid_7_1  m     -Inf     2.08 #>  8 fid_8  fid_8_1  m     -Inf     2.44 #>  9 fid_9  fid_9_1  m     -Inf     2.36 #> 10 fid_10 fid_10_1 m     -Inf     2.55 #> # ℹ 1,490 more rows #>  simulate_under_LTM_single(fam_vec = c(), n_fam = NULL, add_ind = TRUE, h2 = 0.5, n_sim = 200, pop_prev = 0.05) #> Warning: Neither fam_vec nor n_fam is specified... #> $sim_obs #> # A tibble: 200 × 5 #>    fid         g      o o_status o_aoo #>    <chr>   <dbl>  <dbl> <lgl>    <dbl> #>  1 fid_1   0.377 -0.223 FALSE       10 #>  2 fid_2  -0.189 -0.622 FALSE       27 #>  3 fid_3  -0.901 -0.657 FALSE       36 #>  4 fid_4  -0.298 -1.36  FALSE       17 #>  5 fid_5  -0.718 -1.32  FALSE       33 #>  6 fid_6   0.886  0.775 FALSE       28 #>  7 fid_7   0.242  1.93  TRUE        61 #>  8 fid_8   0.547  1.32  FALSE       23 #>  9 fid_9   0.290  1.04  FALSE       13 #> 10 fid_10 -0.691 -0.766 FALSE       34 #> # ℹ 190 more rows #>  #> $thresholds #> # A tibble: 200 × 5 #>    fid    indiv_ID role    lower upper #>    <chr>  <chr>    <chr>   <dbl> <dbl> #>  1 fid_1  fid_1_1  o     -Inf     3.73 #>  2 fid_2  fid_2_1  o     -Inf     3.16 #>  3 fid_3  fid_3_1  o     -Inf     2.82 #>  4 fid_4  fid_4_1  o     -Inf     3.50 #>  5 fid_5  fid_5_1  o     -Inf     2.94 #>  6 fid_6  fid_6_1  o     -Inf     3.12 #>  7 fid_7  fid_7_1  o        1.93  1.93 #>  8 fid_8  fid_8_1  o     -Inf     3.30 #>  9 fid_9  fid_9_1  o     -Inf     3.63 #> 10 fid_10 fid_10_1 o     -Inf     2.90 #> # ℹ 190 more rows #>"},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Title: Calculate the mean of the truncated normal distribution — tnorm_mean","title":"Title: Calculate the mean of the truncated normal distribution — tnorm_mean","text":"Title: Calculate mean truncated normal distribution","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title: Calculate the mean of the truncated normal distribution — tnorm_mean","text":"","code":"tnorm_mean(mu = 0, sigma = 1, lower = -Inf, upper = Inf)"},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title: Calculate the mean of the truncated normal distribution — tnorm_mean","text":"mu mean value normal distribution sigma standard deviation normal distribution lower lower threshold upper upper threshold","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title: Calculate the mean of the truncated normal distribution — tnorm_mean","text":"mean value truncated normal distribution","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Title: Calculate the mean of the truncated normal distribution — tnorm_mean","text":"","code":"tnorm_mean() #> [1] 0"},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_mixture_conditional.html","id":null,"dir":"Reference","previous_headings":"","what":"Title: Calculates mean and variance of mixture of two truncated normal distributions — tnorm_mixture_conditional","title":"Title: Calculates mean and variance of mixture of two truncated normal distributions — tnorm_mixture_conditional","text":"Title: Calculates mean variance mixture two truncated normal distributions","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_mixture_conditional.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title: Calculates mean and variance of mixture of two truncated normal distributions — tnorm_mixture_conditional","text":"","code":"tnorm_mixture_conditional(mu, var, lower, upper, K_i, K_pop)"},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_mixture_conditional.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title: Calculates mean and variance of mixture of two truncated normal distributions — tnorm_mixture_conditional","text":"mu Mean value normal distribution. var Variance normal distribution. lower Lower threshold (can -Inf). upper Upper threshold (can Inf). K_i (Stratified) cumulative incidence proportion individual. K_pop Population prevalence (cumulative incidence proportion).","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_mixture_conditional.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title: Calculates mean and variance of mixture of two truncated normal distributions — tnorm_mixture_conditional","text":"mean variance mixture distribution two truncated normal distributions","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_mixture_conditional.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Title: Calculates mean and variance of mixture of two truncated normal distributions — tnorm_mixture_conditional","text":"","code":"tnorm_mixture_conditional(mu = 0, var = 1, lower = -Inf, upper = Inf, K_i = 0, K_pop = 0.01) #> $mean #> [1] 0 #>  #> $var #> [1] 1 #>  tnorm_mixture_conditional(mu = 0, var = 1, lower = -Inf, upper = 2, K_i = .01, K_pop = 0.05) #> $mean #> [1] 0.04287187 #>  #> $var #> [1] 1.083906 #>"},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Title: Calculate the variance of the truncated normal distribution — tnorm_var","title":"Title: Calculate the variance of the truncated normal distribution — tnorm_var","text":"Title: Calculate variance truncated normal distribution","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title: Calculate the variance of the truncated normal distribution — tnorm_var","text":"","code":"tnorm_var(mu = 0, sigma = 1, lower = -Inf, upper = Inf)"},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title: Calculate the variance of the truncated normal distribution — tnorm_var","text":"mu mean value normal distribution sigma standard deviation normal distribution lower lower threshold upper upper threshold","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title: Calculate the variance of the truncated normal distribution — tnorm_var","text":"mean value truncated normal distribution","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/tnorm_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Title: Calculate the variance of the truncated normal distribution — tnorm_var","text":"","code":"tnorm_var() #> [1] 1"},{"path":"https://emilmip.github.io/LTFGRS/reference/truncated_normal_cdf.html","id":null,"dir":"Reference","previous_headings":"","what":"CDF for truncated normal distribution. — truncated_normal_cdf","title":"CDF for truncated normal distribution. — truncated_normal_cdf","text":"truncated_normal_cdf computes cumulative density function truncated normal distribution.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/truncated_normal_cdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CDF for truncated normal distribution. — truncated_normal_cdf","text":"","code":"truncated_normal_cdf(   liability,   lower = stats::qnorm(0.05, lower.tail = FALSE),   upper = Inf )"},{"path":"https://emilmip.github.io/LTFGRS/reference/truncated_normal_cdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CDF for truncated normal distribution. — truncated_normal_cdf","text":"liability number representing individual's true underlying liability. lower number representing lower cutoff point truncated normal distribution. Defaults 1.645 (stats::qnorm(0.05, lower.tail = FALSE)). upper number representing upper cutoff point truncated normal distribution. Must greater equal lower. Defaults Inf.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/truncated_normal_cdf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CDF for truncated normal distribution. — truncated_normal_cdf","text":"liability number lower upper cutoff points numbers satisfying lower <= upper, truncated_normal_cdf returns probability liability take value less equal liability.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/truncated_normal_cdf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CDF for truncated normal distribution. — truncated_normal_cdf","text":"function can used compute value cumulative density function truncated normal distribution given individual's true underlying liability.","code":""},{"path":"https://emilmip.github.io/LTFGRS/reference/truncated_normal_cdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CDF for truncated normal distribution. — truncated_normal_cdf","text":"","code":"curve(sapply(liability, truncated_normal_cdf), from = qnorm(0.05, lower.tail = FALSE), to = 3.5,  xname = \"liability\")"},{"path":"https://emilmip.github.io/LTFGRS/news/index.html","id":"ltfgrs-010","dir":"Changelog","previous_headings":"","what":"LTFGRS 0.1.0","title":"LTFGRS 0.1.0","text":"Initial CRAN submission.","code":""}]
